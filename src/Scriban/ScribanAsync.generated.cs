//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#if !SCRIBAN_NO_ASYNC
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Scriban.Helpers;
using Scriban.Parsing;
using Scriban.Runtime;
using Scriban.Syntax;
using System.Numerics;
namespace Scriban
{
    /// <summary>
    /// Basic entry point class to parse templates and render them. For more advanced scenario, you should use <see cref="TemplateContext"/> directly.
    /// </summary>
#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class Template
    {

        /// <summary>
        /// Evaluates the template using the specified context. See remarks.
        /// </summary>
        /// <param name="context">The template context.</param>
        /// <param name="render"><c>true</c> to render the output to the <see cref="TemplateContext.Output"/></param>
        /// <exception cref="System.ArgumentNullException">If context is null</exception>
        /// <exception cref="System.InvalidOperationException">If the template <see cref="HasErrors"/>. Check the <see cref="Messages"/> property for more details</exception>
        private async ValueTask<object> EvaluateAndRenderAsync(TemplateContext context, bool render)
        {
            if (context == null) throw new ArgumentNullException(nameof(context));
            CheckErrors();

            // Make sure that we are using the same parserOptions
            if (SourceFilePath != null)
            {
                context.PushSourceFile(SourceFilePath);
            }

            try
            {
                context.UseScientific = LexerOptions.Lang == ScriptLang.Scientific;
                var result = await context.EvaluateAsync(Page).ConfigureAwait(false);
                if (render)
                {
                    if (Page != null && context.EnableOutput && result != null)
                    {
                        await context.WriteAsync(Page.Span, result).ConfigureAwait(false);
                    }
                }
                return result;
            }
            finally
            {
                if (SourceFilePath != null)
                {
                    context.PopSourceFile();
                }
            }
        }

        /// <summary>
        /// Evaluates the template using the specified context. See remarks.
        /// </summary>
        /// <param name="context">The template context.</param>
        /// <exception cref="System.ArgumentNullException">If context is null</exception>
        /// <exception cref="System.InvalidOperationException">If the template <see cref="HasErrors"/>. Check the <see cref="Messages"/> property for more details</exception>
        /// <returns>Returns the result of the last statement</returns>
        public async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var previousOutput = context.EnableOutput;
            try
            {
                context.UseScientific = LexerOptions.Lang == ScriptLang.Scientific;
                context.EnableOutput = false;
                return await EvaluateAndRenderAsync(context, false).ConfigureAwait(false);
            }
            finally
            {
                context.EnableOutput = previousOutput;
            }
        }

        /// <summary>
        /// Parse and evaluates a code only expression (without enclosing `{{` and `}}`) within the specified context.
        /// </summary>
        /// <param name="expression">A code only expression (without enclosing `{{` and `}}`)</param>
        /// <param name="context">The template context</param>
        /// <returns>The result of the evaluation of the expression</returns>
        public static async ValueTask<object> EvaluateAsync(string expression, TemplateContext context)
        {
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            var lexerOption = new LexerOptions() { Mode = ScriptMode.ScriptOnly };
            var template = Parse(expression, lexerOptions: lexerOption);
            return await template.EvaluateAsync(context).ConfigureAwait(false);
        }

        /// <summary>
        /// Evaluates the template using the specified context
        /// </summary>
        /// <param name="model">An object model to use with the evaluation.</param>
        /// <param name="memberRenamer">The member renamer used to import this .NET object and transitive objects. See member renamer documentation for more details.</param>
        /// <param name="memberFilter">The member filter used to filter members for .NET objects being accessed through the template, including the model being passed to this method.</param>
        /// <exception cref="System.InvalidOperationException">If the template <see cref="HasErrors"/>. Check the <see cref="Messages"/> property for more details</exception>
        /// <returns>Returns the result of the last statement</returns>
        public async ValueTask<object> EvaluateAsync(object model = null, MemberRenamerDelegate memberRenamer = null, MemberFilterDelegate memberFilter = null)
        {
            var scriptObject = new ScriptObject();
            if (model != null)
            {
                scriptObject.Import(model, renamer: memberRenamer, filter: memberFilter);
            }

            var context = LexerOptions.Lang == ScriptLang.Liquid ? new LiquidTemplateContext() : new TemplateContext();
            context.EnableOutput = false;
            context.MemberRenamer = memberRenamer;
            context.MemberFilter = memberFilter;
            context.UseScientific = LexerOptions.Lang == ScriptLang.Scientific;
            context.PushGlobal(scriptObject);
            var result = await EvaluateAsync(context).ConfigureAwait(false);
            context.PopGlobal();
            return result;
        }

        /// <summary>
        /// Parse and evaluates a code only expression (without enclosing `{{` and `}}`) within the specified context.
        /// </summary>
        /// <param name="expression">A code only expression (without enclosing `{{` and `}}`)</param>
        /// <param name="model">An object instance used as a model for evaluating this expression</param>
        /// <param name="memberRenamer">The member renamer used to import this .NET object and transitive objects. See member renamer documentation for more details.</param>
        /// <param name="memberFilter">The member filter used to filter members for .NET objects being accessed through the template, including the model being passed to this method.</param>
        /// <returns>The result of the evaluation of the expression</returns>
        public static async ValueTask<object> EvaluateAsync(string expression, object model, MemberRenamerDelegate memberRenamer = null, MemberFilterDelegate memberFilter = null)
        {
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            var lexerOption = new LexerOptions() { Mode = ScriptMode.ScriptOnly };
            var template = Parse(expression, lexerOptions: lexerOption);
            return await template.EvaluateAsync(model, memberRenamer, memberFilter).ConfigureAwait(false);
        }

        /// <summary>
        /// Renders this template using the specified context. See remarks.
        /// </summary>
        /// <param name="context">The template context.</param>
        /// <exception cref="System.ArgumentNullException">If context is null</exception>
        /// <exception cref="System.InvalidOperationException">If the template <see cref="HasErrors"/>. Check the <see cref="Messages"/> property for more details</exception>
        /// <remarks>
        /// When using this method, the result of rendering this page is output to <see cref="TemplateContext.Output"/>
        /// </remarks>
        public async ValueTask<string> RenderAsync(TemplateContext context)
        {
            await EvaluateAndRenderAsync(context, true).ConfigureAwait(false);
            var result = context.Output.ToString();
            var output = context.Output as StringBuilderOutput;
            if (output != null)
            {
                output.Builder.Length = 0;
            }
            return result;
        }

        /// <summary>
        /// Renders this template using the specified object model.
        /// </summary>
        /// <param name="model">The object model.</param>
        /// <param name="memberRenamer">The member renamer used to import this .NET object and transitive objects. See member renamer documentation for more details.</param>
        /// <param name="memberFilter">The member filter used to filter members for .NET objects being accessed through the template, including the model being passed to this method.</param>
        /// <returns>A rendering result as a string </returns>
        public async ValueTask<string> RenderAsync(object model = null, MemberRenamerDelegate memberRenamer = null, MemberFilterDelegate memberFilter = null)
        {
            var scriptObject = new ScriptObject();
            if (model != null)
            {
                scriptObject.Import(model, renamer: memberRenamer, filter: memberFilter);
            }

            var context = LexerOptions.Lang == ScriptLang.Liquid ? new LiquidTemplateContext() : new TemplateContext();
            context.MemberRenamer = memberRenamer;
            context.MemberFilter = memberFilter;
            context.PushGlobal(scriptObject);
            return await RenderAsync(context).ConfigureAwait(false);
        }
    }
    /// <summary>
    /// The template context contains the state of the page, the model.
    /// </summary>
#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class TemplateContext
    {

        /// <summary>
        /// Evaluates the specified script node.
        /// </summary>
        /// <param name="scriptNode">The script node.</param>
        /// <param name="aliasReturnedFunction">if set to <c>true</c> and a function would be evaluated as part of this node, return the object function without evaluating it.</param>
        /// <returns>The result of the evaluation.</returns>
        public virtual async ValueTask<object> EvaluateAsync(ScriptNode scriptNode, bool aliasReturnedFunction)
        {
            if (scriptNode == null) return null;

            var previousFunctionCallState = _isFunctionCallDisabled;
            var previousLevel = _getOrSetValueLevel;
            var previousNode = CurrentNode;
            try
            {
                CurrentNode = scriptNode;
                _getOrSetValueLevel = 0;
                _isFunctionCallDisabled = aliasReturnedFunction;
                var result = await scriptNode.EvaluateAsync(this).ConfigureAwait(false);
                return result;
            }
            catch (ScriptRuntimeException ex) when (this.RenderRuntimeException != null)
            {
                return this.RenderRuntimeException(ex);
            }
            catch (Exception ex) when (!(ex is ScriptRuntimeException))
            {
                var toThrow = new ScriptRuntimeException(scriptNode.Span, ex.Message, ex);
                if (RenderRuntimeException != null)
                {
                    return RenderRuntimeException(toThrow);
                }
                throw toThrow;
            }
            finally
            {
                CurrentNode = previousNode;
                _getOrSetValueLevel = previousLevel;
                _isFunctionCallDisabled = previousFunctionCallState;
            }
        }

        /// <summary>
        /// Evaluates the specified script node.
        /// </summary>
        /// <param name="scriptNode">The script node.</param>
        /// <returns>The result of the evaluation.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public async ValueTask<object> EvaluateAsync(ScriptNode scriptNode)
        {
            return await EvaluateAsync(scriptNode, false).ConfigureAwait(false);
        }


        /// <summary>
        /// Evaluates the specified expression
        /// </summary>
        /// <param name="targetExpression">The expression to evaluate</param>
        /// <param name="valueToSet">A value to set in case of a setter</param>
        /// <param name="setter">true if this a setter</param>
        /// <returns>The value of the targetExpression</returns>
        private async ValueTask<object> GetOrSetValueAsync(ScriptExpression targetExpression, object valueToSet, bool setter)
        {
            object value = null;

            try
            {
                if (targetExpression is IScriptVariablePath nextPath)
                {
                    if (setter)
                    {
                        await nextPath.SetValueAsync(this, valueToSet).ConfigureAwait(false);
                    }
                    else
                    {
                        value = await nextPath.GetValueAsync(this).ConfigureAwait(false);
                    }
                }
                else if (!setter)
                {
                    value = await EvaluateAsync(targetExpression).ConfigureAwait(false);
                }
                else
                {
                    throw new ScriptRuntimeException(targetExpression.Span, $"Unsupported target expression for assignment."); // unit test: 105-assign-error1.txt
                }
            }
            catch (Exception readonlyException) when (_getOrSetValueLevel == 1 && !(readonlyException is ScriptRuntimeException))
            {
                throw new ScriptRuntimeException(targetExpression.Span, $"Unexpected exception while accessing target expression: {readonlyException.Message}", readonlyException);
            }

            // If the variable being returned is a function, we need to evaluate it
            // If function call is disabled, it will be only when returning the final object (level 0 of recursion)
            var allowFunctionCall = (_isFunctionCallDisabled && _getOrSetValueLevel > 1) || !_isFunctionCallDisabled;
            if (allowFunctionCall && ScriptFunctionCall.IsFunction(value))
            {
                // Allow to pipe arguments only for top level returned function
                value = await ScriptFunctionCall.CallAsync(this, targetExpression, value, _getOrSetValueLevel == 1, null).ConfigureAwait(false);
            }

            return value;
        }

        /// <summary>
        /// Gets the value from the specified expression using the current <see cref="ScriptObject"/> bound to the model context.
        /// </summary>
        /// <param name="target">The expression</param>
        /// <returns>The value of the expression</returns>
        public async ValueTask<object> GetValueAsync(ScriptExpression target)
        {

            var previousNode = CurrentNode;
            _getOrSetValueLevel++;
            try
            {
                CurrentNode = target;
                return await GetOrSetValueAsync(target, null, false).ConfigureAwait(false);
            }
            finally
            {
                CurrentNode = previousNode;
                _getOrSetValueLevel--;
            }
        }

        /// <summary>
        /// Sets the target expression with the specified value.
        /// </summary>
        /// <param name="target">The target expression.</param>
        /// <param name="value">The value.</param>
        /// <exception cref="System.ArgumentNullException">If target is null</exception>
        public async ValueTask SetValueAsync(ScriptExpression target, object value)
        {
            if (target == null) throw new ArgumentNullException(nameof(target));
            _getOrSetValueLevel++;
            try
            {
                await GetOrSetValueAsync(target, value, true).ConfigureAwait(false);
            }
            finally
            {
                _getOrSetValueLevel--;
            }
        }

        /// <summary>
        /// Writes the text to the current <see cref="Output"/>
        /// </summary>
        /// <param name="text">The text.</param>
        /// <param name="startIndex">The zero-based position of the substring of text</param>
        /// <param name="count">The number of characters to output starting at <paramref name="startIndex"/> position from the text</param>
        public async ValueTask<TemplateContext> WriteAsync(string text, int startIndex, int count)
        {
            if (text != null)
            {
                // Indented text
                if (CurrentIndent != null)
                {
                    var index = startIndex;
                    var indexEnd = startIndex + count;

                    while (index < indexEnd)
                    {
                        // Write indents if necessary
                        if (_previousTextWasNewLine)
                        {
                            await Output.WriteAsync(CurrentIndent, 0, CurrentIndent.Length, CancellationToken).ConfigureAwait(false);
                            _previousTextWasNewLine = false;
                        }

                        var newLineIndex = text.IndexOf('\n', index);
                        if (newLineIndex < 0 || newLineIndex >= indexEnd)
                        {
                            await Output.WriteAsync(text, index, indexEnd - index, CancellationToken).ConfigureAwait(false);
                            break;
                        }

                        // We output the new line
                        await Output.WriteAsync(text, index, newLineIndex - index + 1, CancellationToken).ConfigureAwait(false);
                        index = newLineIndex + 1;
                        _previousTextWasNewLine = true;
                    }
                }
                else
                {
                    await Output.WriteAsync(text, startIndex, count, CancellationToken).ConfigureAwait(false);
                }
            }

            return this;
        }

        /// <summary>
        /// Writes the text to the current <see cref="Output"/>
        /// </summary>
        /// <param name="text">The text.</param>
        public async ValueTask<TemplateContext> WriteAsync(string text)
        {
            if (text != null)
            {
                await WriteAsync(text, 0, text.Length).ConfigureAwait(false);
            }
            return this;
        }

        /// <summary>
        /// Writes the text to the current <see cref="Output"/>
        /// </summary>
        /// <param name="slice">The text.</param>
        public async ValueTask<TemplateContext> WriteAsync(ScriptStringSlice slice)
        {
            await WriteAsync(slice.FullText, slice.Index, slice.Length).ConfigureAwait(false);
            return this;
        }

        /// <summary>
        /// Writes an object value to the current <see cref="Output"/>.
        /// </summary>
        /// <param name="span">The span of the object to render.</param>
        /// <param name="textAsObject">The text as object.</param>
        public virtual async ValueTask<TemplateContext> WriteAsync(SourceSpan span, object textAsObject)
        {
            if (textAsObject != null)
            {
                var text = ObjectToString(textAsObject);
                await WriteAsync(text).ConfigureAwait(false);
            }
            return this;
        }

        /// <summary>
        /// Writes the a new line to the current <see cref="Output"/>
        /// </summary>
        public async ValueTask<TemplateContext> WriteLineAsync()
        {
            await WriteAsync(NewLine).ConfigureAwait(false);
            return this;
        }
    }
}

namespace Scriban.Functions
{
    /// <summary>
    /// The include function available through the function 'include' in scriban.
    /// </summary>
#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    sealed partial class IncludeFunction
    {

        public async ValueTask<object> InvokeAsync(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement)
        {
            if (arguments.Count == 0)
            {
                throw new ScriptRuntimeException(callerContext.Span, "Expecting at least the name of the template to include for the <include> function");
            }

            var templateName = context.ObjectToString(arguments[0]);

            // If template name is empty, throw an exception
            if (string.IsNullOrEmpty(templateName))
            {
                // In a liquid template context, we let an include to continue without failing
                if (context is LiquidTemplateContext)
                {
                    return null;
                }
                throw new ScriptRuntimeException(callerContext.Span, $"Include template name cannot be null or empty");
            }

            var templateLoader = context.TemplateLoader;
            if (templateLoader == null)
            {
                throw new ScriptRuntimeException(callerContext.Span, $"Unable to include <{templateName}>. No TemplateLoader registered in TemplateContext.TemplateLoader");
            }

            string templatePath;

            try
            {
                templatePath = templateLoader.GetPath(context, callerContext.Span, templateName);
            }
            catch (Exception ex) when (!(ex is ScriptRuntimeException))
            {
                throw new ScriptRuntimeException(callerContext.Span, $"Unexpected exception while getting the path for the include name `{templateName}`", ex);
            }
            // If template path is empty (probably because template doesn't exist), throw an exception
            if (templatePath == null)
            {
                throw new ScriptRuntimeException(callerContext.Span, $"Include template path is null for `{templateName}");
            }

            Template template;

            if (!context.CachedTemplates.TryGetValue(templatePath, out template))
            {

                string templateText;
                try
                {
                    templateText = await templateLoader.LoadAsync(context, callerContext.Span, templatePath).ConfigureAwait(false);
                }
                catch (Exception ex) when (!(ex is ScriptRuntimeException))
                {
                    throw new ScriptRuntimeException(callerContext.Span, $"Unexpected exception while loading the include `{templateName}` from path `{templatePath}`", ex);
                }

                if (templateText == null)
                {
                    throw new ScriptRuntimeException(callerContext.Span, $"The result of including `{templateName}->{templatePath}` cannot be null");
                }

                // Clone parser options
                var parserOptions = context.TemplateLoaderParserOptions;
                var lexerOptions = context.TemplateLoaderLexerOptions;
                template = Template.Parse(templateText, templatePath, parserOptions, lexerOptions);

                // If the template has any errors, throw an exception
                if (template.HasErrors)
                {
                    throw new ScriptParserRuntimeException(callerContext.Span, $"Error while parsing template `{templateName}` from `{templatePath}`", template.Messages);
                }

                context.CachedTemplates.Add(templatePath, template);
            }

            // Make sure that we cannot recursively include a template
            object result = null;
            context.EnterRecursive(callerContext);
            var previousIndent = context.CurrentIndent;
            context.CurrentIndent = null;
            context.PushOutput();
            var previousArguments = await context.GetValueAsync(ScriptVariable.Arguments).ConfigureAwait(false);
            try
            {
                context.SetValue(ScriptVariable.Arguments, arguments, true, true);
                if (previousIndent != null)
                {
                    // We reset before and after the fact that we have a new line
                    context.ResetPreviousNewLine();
                }
                result = await template.RenderAsync(context).ConfigureAwait(false);
                if (previousIndent != null)
                {
                    context.ResetPreviousNewLine();
                }
            }
            finally
            {
                context.PopOutput();
                context.CurrentIndent = previousIndent;
                context.ExitRecursive(callerContext);

                // Remove the arguments
                context.DeleteValue(ScriptVariable.Arguments);
                if (previousArguments != null)
                {
                    // Restore them if necessary
                    context.SetValue(ScriptVariable.Arguments, previousArguments, true);
                }
            }
            return result;
        }
    }
}

namespace Scriban.Runtime
{
#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    abstract partial class DynamicCustomFunction
    {


        protected async ValueTask<ArgumentValue> GetValueFromNamedArgumentAsync(TemplateContext context, ScriptNode callerContext, ScriptNamedArgument namedArg)
        {
            for (int j = 0; j < Parameters.Length; j++)
            {
                var arg = Parameters[j];
                if (arg.Name == namedArg.Name.Name)
                {
                    return new ArgumentValue(j, arg.ParameterType, await context.EvaluateAsync(namedArg).ConfigureAwait(false));
                }
            }
            throw new ScriptRuntimeException(callerContext.Span, $"Invalid argument `{namedArg.Name}` not found for function `{callerContext}`");
        }

    }

    /// <summary>
    /// Extensions for <see cref="IScriptOutput"/>
    /// </summary>
#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    static partial class ScriptOutputExtensions
    {
        public static async ValueTask WriteAsync(this IScriptOutput scriptOutput, string text, CancellationToken cancellationToken)
        {
            if (text == null) throw new ArgumentNullException(nameof(text));
            await scriptOutput.WriteAsync(text, 0, text.Length, cancellationToken).ConfigureAwait(false);
        }

        public static async ValueTask WriteAsync(this IScriptOutput scriptOutput, ScriptStringSlice text, CancellationToken cancellationToken)
        {
            if (text.FullText == null) throw new ArgumentNullException(nameof(text));
            if (text.Length == 0) return;
            await scriptOutput.WriteAsync(text.FullText, text.Index, text.Length, cancellationToken).ConfigureAwait(false);
        }
    }
}
namespace Scriban.Syntax
{
    /// <summary>
        /// Used to rewrite a function call expression at evaluation time based
        /// on the arguments required by a function. Used by scientific mode scripting.
        /// </summary>
    internal partial class ScientificFunctionCallRewriter
    {
        private static async ValueTask FlattenBinaryExpressionsAsync(TemplateContext context, ScriptExpression expression, List<BinaryExpressionOrOperator> expressions)
        {
            while (true)
            {
                if (!(expression is ScriptBinaryExpression binaryExpression))
                {
                    expressions.Add(new BinaryExpressionOrOperator(expression, await GetFunctionCallKindAsync(context, expression).ConfigureAwait(false)));
                    return;
                }

                var left = (ScriptExpression)binaryExpression.Left.Clone();
                var right = (ScriptExpression)binaryExpression.Right.Clone();
                var token = (ScriptToken)binaryExpression.OperatorToken?.Clone();
                await FlattenBinaryExpressionsAsync(context, left, expressions).ConfigureAwait(false);
                expressions.Add(new BinaryExpressionOrOperator(binaryExpression.Operator, token));
                // Iterate on right (equivalent to tail recursive call)
                expression = right;
            }
        }

        private static async ValueTask<FunctionCallKind> GetFunctionCallKindAsync(TemplateContext context, ScriptExpression expression)
        {
            var restoreStrictVariables = context.StrictVariables;
            // Don't fail on trying to lookup for a variable
            context.StrictVariables = false;
            object result = null;
            try
            {
                result = await context.EvaluateAsync(expression, true).ConfigureAwait(false);
            }
            catch (ScriptRuntimeException) when (context.IgnoreExceptionsWhileRewritingScientific)
            {
                // ignore any exceptions during trial evaluating as we could try to evaluate
                // variable that aren't setup
            }
            finally
            {
                context.StrictVariables = restoreStrictVariables;
            }

            // If one argument is a function, the remaining arguments
            if (result is IScriptCustomFunction function)
            {
                var maxArg = function.RequiredParameterCount != 0 ? function.RequiredParameterCount : function.ParameterCount > 0 ? 1 : 0;
                // We match all functions with at least one argument.
                // If we are expecting more than one argument, let the error happen later with the function call.
                if (maxArg > 0)
                {
                    var isExpectingExpression = function.IsParameterType<ScriptExpression>(0);
                    return isExpectingExpression ? FunctionCallKind.Expression : FunctionCallKind.Regular;
                }
            }

            return FunctionCallKind.None;
        }

        public static async ValueTask<ScriptExpression> RewriteAsync(TemplateContext context, ScriptBinaryExpression binaryExpression)
        {
            Debug.Assert(ImplicitFunctionCallPrecedence < Parser.PrecedenceOfMultiply);
            if (!HasImplicitBinaryExpression(binaryExpression))
            {
                return binaryExpression;
            }

            // TODO: use a TLS cache
            var iterator = new BinaryExpressionIterator();
            // a b c / d + e
            // stack will contain:
            // [0] a
            // [1] implicit *
            // [2] b
            // [3] implicit *
            // [4] c
            // [5] /
            // [6] d
            // [7] +
            // [8] e
            await FlattenBinaryExpressionsAsync(context, binaryExpression, iterator).ConfigureAwait(false);
            return ParseBinaryExpressionTree(iterator, 0, false);
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptArrayInitializerExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var scriptArray = new ScriptArray();
            foreach (var value in Values)
            {
                var valueEval = await context.EvaluateAsync(value).ConfigureAwait(false);
                scriptArray.Add(valueEval);
            }

            return scriptArray;
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptAssignExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var valueObject = EqualToken.TokenType == TokenType.Equal ? await context.EvaluateAsync(Value).ConfigureAwait(false) : await GetValueToSetAsync(context).ConfigureAwait(false);
            await context.SetValueAsync(Target, valueObject).ConfigureAwait(false);
            return null;
        }

        private async ValueTask<object> GetValueToSetAsync(TemplateContext context)
        {
            var right = await context.EvaluateAsync(Value).ConfigureAwait(false);
            var left = await context.EvaluateAsync(Target).ConfigureAwait(false);
            var op = this.EqualToken.TokenType switch
            {
                TokenType.PlusEqual => ScriptBinaryOperator.Add,
                TokenType.MinusEqual => ScriptBinaryOperator.Subtract,
                TokenType.AsteriskEqual => ScriptBinaryOperator.Multiply,
                TokenType.DivideEqual => ScriptBinaryOperator.Divide,
                TokenType.DoubleDivideEqual => ScriptBinaryOperator.DivideRound,
                TokenType.PercentEqual => ScriptBinaryOperator.Modulus,
                _ => throw new ScriptRuntimeException(context.CurrentSpan, $"Operator {this.EqualToken} is not a valid compound assignment operator"),
            };
            return ScriptBinaryExpression.Evaluate(context, this.Span, op, left, right);
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptBinaryExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            // If we are in scientific mode and we have a function which takes arguments, and is not an explicit call (e.g sin(x) rather then sin * x)
            // Then we need to rewrite the call to a proper expression.
            if (context.UseScientific)
            {
                var newExpression = await ScientificFunctionCallRewriter.RewriteAsync(context, this).ConfigureAwait(false);
                if (!ReferenceEquals(newExpression, this))
                {
                    return await context.EvaluateAsync(newExpression).ConfigureAwait(false);
                }
            }

            var leftValue = await context.EvaluateAsync(Left).ConfigureAwait(false);
            switch (Operator)
            {
                case ScriptBinaryOperator.And:
                    {
                        var leftBoolValue = context.ToBool(Left.Span, leftValue);
                        if (!leftBoolValue)
                            return false;
                        var rightValue = await context.EvaluateAsync(Right).ConfigureAwait(false);
                        var rightBoolValue = context.ToBool(Right.Span, rightValue);
                        return leftBoolValue && rightBoolValue;
                    }

                case ScriptBinaryOperator.Or:
                    {
                        var leftBoolValue = context.ToBool(Left.Span, leftValue);
                        if (leftBoolValue)
                            return true;
                        var rightValue = await context.EvaluateAsync(Right).ConfigureAwait(false);
                        return context.ToBool(Right.Span, rightValue);
                    }

                default:
                    {
                        var rightValue = await context.EvaluateAsync(Right).ConfigureAwait(false);
                        return Evaluate(context, OperatorToken?.Span ?? Span, Operator, Left.Span, leftValue, Right.Span, rightValue);
                    }
            }
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptBlockStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var autoIndent = context.AutoIndent;
            object result = null;
            var statements = Statements;
            string previousIndent = context.CurrentIndent;
            string currentIndent = previousIndent;
            try
            {
                for (int i = 0; i < statements.Count; i++)
                {
                    var statement = statements[i];
                    // Throws a cancellation
                    context.CheckAbort();
                    if (autoIndent && statement is ScriptEscapeStatement escape)
                    {
                        if (escape.IsEntering)
                        {
                            currentIndent = escape.Indent;
                        }
                        else if (escape.IsClosing)
                        {
                            currentIndent = previousIndent;
                        }
                    }

                    context.CurrentIndent = currentIndent;
                    if (statement.CanSkipEvaluation)
                    {
                        continue;
                    }

                    result = await context.EvaluateAsync(statement).ConfigureAwait(false);
                    // Top-level assignment expression don't output anything
                    if (!statement.CanOutput)
                    {
                        result = null;
                    }
                    else if (result != null && context.FlowState != ScriptFlowState.Return && context.EnableOutput)
                    {
                        await context.WriteAsync(Span, result).ConfigureAwait(false);
                        result = null;
                    }

                    // If flow state is different, we need to exit this loop
                    if (context.FlowState != ScriptFlowState.None)
                    {
                        break;
                    }
                }
            }
            finally
            {
                context.CurrentIndent = previousIndent;
            }

            return result;
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptCaptureStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            // unit test: 230-capture-statement.txt
            context.PushOutput();
            try
            {
                await context.EvaluateAsync(Body).ConfigureAwait(false);
            }
            finally
            {
                var result = context.PopOutput();
                await context.SetValueAsync(Target, result).ConfigureAwait(false);
            }

            return null;
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptCaseStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var caseValue = await context.EvaluateAsync(Value).ConfigureAwait(false);
            context.PushCase(caseValue);
            try
            {
                return await context.EvaluateAsync(Body).ConfigureAwait(false);
            }
            finally
            {
                context.PopCase();
            }
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptConditionalExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var condValue = await context.EvaluateAsync(Condition).ConfigureAwait(false);
            var result = context.ToBool(Condition.Span, condValue);
            return await context.EvaluateAsync(result ? ThenValue : ElseValue).ConfigureAwait(false);
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptElseStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            return await context.EvaluateAsync(Body).ConfigureAwait(false);
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptExpressionStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var result = await context.EvaluateAsync(Expression).ConfigureAwait(false);
            // This code is necessary for wrap to work
            var codeDelegate = result as ScriptNode;
            if (codeDelegate != null)
            {
                return await context.EvaluateAsync(codeDelegate).ConfigureAwait(false);
            }

            return result;
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptForStatement
    {
        protected override async ValueTask<object> EvaluateImplAsync(TemplateContext context)
        {
            var loopIterator = await context.EvaluateAsync(Iterator).ConfigureAwait(false);
            if (loopIterator is System.Linq.IQueryable queryable)
            {
                // Value is a queryable, use Linq and deferred execution
                return await LoopQueryableAsync(context, queryable).ConfigureAwait(false);
            }

            var list = loopIterator as IList;
            if (list == null)
            {
                if (loopIterator is IEnumerable iterator)
                {
                    list = new ScriptArray(iterator);
                }
            }

            if (list != null)
            {
                object loopResult = null;
                object previousValue = null;
                bool reversed = false;
                int startIndex = 0;
                int limit = list.Count;
                if (NamedArguments != null)
                {
                    foreach (var option in NamedArguments)
                    {
                        switch (option.Name.Name)
                        {
                            case "offset":
                                startIndex = context.ToInt(option.Value.Span, await context.EvaluateAsync(option.Value).ConfigureAwait(false));
                                break;
                            case "reversed":
                                reversed = true;
                                break;
                            case "limit":
                                limit = context.ToInt(option.Value.Span, await context.EvaluateAsync(option.Value).ConfigureAwait(false));
                                break;
                            default:
                                await ProcessArgumentAsync(context, option).ConfigureAwait(false);
                                break;
                        }
                    }
                }

                var endIndex = Math.Min(limit + startIndex, list.Count) - 1;
                var index = reversed ? endIndex : startIndex;
                var dir = reversed ? -1 : 1;
                bool isFirst = true;
                int i = 0;
                await BeforeLoopAsync(context).ConfigureAwait(false);
                var loopState = CreateLoopState();
                context.SetLoopVariable(GetLoopVariable(context), loopState);
                loopState.Length = list.Count;
                bool enteredLoop = false;
                while (!reversed && index <= endIndex || reversed && index >= startIndex)
                {
                    enteredLoop = true;
                    if (!context.StepLoop(this))
                    {
                        return null;
                    }

                    // We update on next run on previous value (in order to handle last)
                    var value = list[index];
                    bool isLast = reversed ? index == startIndex : index == endIndex;
                    loopState.Index = index;
                    loopState.LocalIndex = i;
                    loopState.IsLast = isLast;
                    loopState.ValueChanged = isFirst || !Equals(previousValue, value);
                    if (Variable is ScriptVariable loopVariable)
                    {
                        context.SetLoopVariable(loopVariable, value);
                    }
                    else
                    {
                        await context.SetValueAsync(Variable, value).ConfigureAwait(false);
                    }

                    loopResult = await LoopItemAsync(context, loopState).ConfigureAwait(false);
                    if (!ContinueLoop(context))
                    {
                        break;
                    }

                    previousValue = value;
                    isFirst = false;
                    index += dir;
                    i++;
                }

                await AfterLoopAsync(context).ConfigureAwait(false);
                if (SetContinue)
                {
                    context.SetValue(ScriptVariable.Continue, index);
                }

                if (!enteredLoop && Else != null)
                {
                    loopResult = await context.EvaluateAsync(Else).ConfigureAwait(false);
                }

                return loopResult;
            }

            if (loopIterator != null)
            {
                throw new ScriptRuntimeException(Iterator.Span, $"Unexpected type `{loopIterator.GetType()}` for iterator");
            }

            return null;
        }

        /// <summary>
                /// Use Linq IQueryable extension methods
                /// </summary>
                /// <param name = "context"></param>
                /// <param name = "queryable"></param>
                /// <returns></returns>
        private async ValueTask<System.Linq.IQueryable> HandleQueryableArgumentsAsync(TemplateContext context, System.Linq.IQueryable queryable)
        {
            if (NamedArguments == null || NamedArguments.Count == 0)
                return queryable;
            var typeOfT = queryable.GetType().GetGenericArguments()[0];
            System.Linq.IQueryable InvokeQueryableMethod(string methodName, params object[] parameters)
            {
                var methodInfo = typeof(System.Linq.Queryable).GetMethod(methodName);
                methodInfo = methodInfo.MakeGenericMethod(typeOfT);
                return (System.Linq.IQueryable)methodInfo.Invoke(null, parameters);
            }

            foreach (var option in NamedArguments)
            {
                switch (option.Name.Name)
                {
                    case "offset": // call IQueryable<T>.Skip(count) extension method
                        {
                            var startIndex = context.ToInt(option.Value.Span, await context.EvaluateAsync(option.Value).ConfigureAwait(false));
                            queryable = InvokeQueryableMethod(nameof(System.Linq.Queryable.Skip), queryable, startIndex);
                            break;
                        }

                    case "reversed": // call IQueryable<T>.Reverse() extension method
                        {
                            queryable = InvokeQueryableMethod(nameof(System.Linq.Queryable.Reverse), queryable);
                            break;
                        }

                    case "limit": // call IQueryable<T>.Take(count) extension method
                        {
                            var limit = context.ToInt(option.Value.Span, await context.EvaluateAsync(option.Value).ConfigureAwait(false));
#if NET6_0_OR_GREATER
                            var methodInfo = Array.Find(
                                typeof(System.Linq.Queryable).GetMethods(),
                                x => x.Name == nameof(System.Linq.Queryable.Take) && x.GetParameters()[1].ParameterType == typeof(int));

                            methodInfo = methodInfo.MakeGenericMethod(typeOfT);

                            queryable = (System.Linq.IQueryable)methodInfo.Invoke(null, new object[] { queryable, limit });
#else
                            queryable = InvokeQueryableMethod(nameof(System.Linq.Queryable.Take), queryable, limit);
#endif
                            break;
                        }

                    default:
                        {
                            await ProcessArgumentAsync(context, option).ConfigureAwait(false);
                            break;
                        }
                }
            }

            return queryable;
        }

        protected override async ValueTask<object> LoopItemAsync(TemplateContext context, LoopState state)
        {
            return await context.EvaluateAsync(Body).ConfigureAwait(false);
        }

        /// <summary>
                /// Loop over an IQueryable value
                /// </summary>
                /// <param name = "context"></param>
                /// <param name = "queryable"></param>
                /// <returns></returns>
        private async ValueTask<object> LoopQueryableAsync(TemplateContext context, System.Linq.IQueryable queryable)
        {
            var loopResult = default(object);
            queryable = await HandleQueryableArgumentsAsync(context, queryable).ConfigureAwait(false);
            await BeforeLoopAsync(context).ConfigureAwait(false);
            var loopState = CreateLoopState();
            context.SetValue(GetLoopVariable(context), loopState);
            var previousValue = default(object);
            var index = 0;
            var enteredLoop = false;
            foreach (var value in queryable)
            {
                if (!context.StepLoop(this, TemplateContext.LoopType.Queryable))
                    return default;
                loopState.Index = index;
                loopState.LocalIndex = index;
                loopState.ValueChanged = index == 0 || !Equals(previousValue, value);
                if (Variable is ScriptVariable loopVariable)
                    context.SetLoopVariable(loopVariable, value);
                else
                    await context.SetValueAsync(Variable, value).ConfigureAwait(false);
                loopResult = await LoopItemAsync(context, default).ConfigureAwait(false);
                if (!ContinueLoop(context))
                    break;
                previousValue = value;
                index++;
            }

            await AfterLoopAsync(context).ConfigureAwait(false);
            if (SetContinue)
                context.SetValue(ScriptVariable.Continue, index);
            if (!enteredLoop && Else != default)
                loopResult = await context.EvaluateAsync(Else).ConfigureAwait(false);
            return loopResult;
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptFrontMatter
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            return await context.EvaluateAsync(Statements).ConfigureAwait(false);
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptFunction
    {
        public async ValueTask<object> InvokeAsync(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement)
        {
            bool hasParams = HasParameters;
            if (hasParams)
            {
                context.PushGlobal(new ScriptObject());
            }
            else
            {
                context.PushLocal();
            }

            try
            {
                if (NameOrDoToken is ScriptVariableLocal localVariable)
                {
                    context.SetValue(localVariable, this);
                }

                context.SetValue(ScriptVariable.Arguments, arguments, true);
                if (hasParams)
                {
                    var glob = context.CurrentGlobal;
                    for (var i = 0; i < Parameters.Count; i++)
                    {
                        var param = Parameters[i];
                        glob.SetValue(param.Name.Name, arguments[i], false);
                    }
                }

                // Set the block delegate
                if (blockStatement != null)
                {
                    context.SetValue(ScriptVariable.BlockDelegate, blockStatement, true);
                }

                var result = await context.EvaluateAsync(Body).ConfigureAwait(false);
                return result;
            }
            finally
            {
                if (hasParams)
                {
                    context.PopGlobal();
                }
                else
                {
                    context.PopLocal();
                }
            }
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptFunctionCall
    {
        public static async ValueTask<object> CallAsync(TemplateContext context, ScriptNode callerContext, object functionObject, bool processPipeArguments, IReadOnlyList<ScriptExpression> arguments)
        {
            if (context == null)
                throw new ArgumentNullException(nameof(context));
            // Pop immediately the block
            ScriptBlockStatement blockDelegate = null;
            if (context.BlockDelegates.Count > 0)
            {
                blockDelegate = context.BlockDelegates.Pop();
            }

            if (callerContext == null)
                throw new ArgumentNullException(nameof(callerContext));
            if (functionObject == null)
            {
                throw new ScriptRuntimeException(callerContext.Span, $"The target function `{callerContext}` is null");
            }

            var scriptFunction = functionObject as ScriptFunction;
            var function = functionObject as IScriptCustomFunction;
            var isPipeCall = processPipeArguments && context.CurrentPipeArguments != null && context.CurrentPipeArguments.Count > 0;
            if (function == null)
            {
                if ((isPipeCall) && (callerContext is ScriptFunctionCall funcCall))
                {
                    throw new ScriptRuntimeException(callerContext.Span, $"Pipe expression destination `{funcCall.Target}` is not a valid function ");
                }
                else
                {
                    throw new ScriptRuntimeException(callerContext.Span, $"Invalid target function `{functionObject}` ({context.GetTypeName(functionObject)})");
                }
            }

            if (function.ParameterCount >= MaximumParameterCount)
            {
                throw new ScriptRuntimeException(callerContext.Span, $"Out of range number of parameters {function.ParameterCount} for target function `{functionObject}`. The maximum number of parameters for a function is: {MaximumParameterCount}.");
            }

            // Generates an error only if the context is configured for it
            if (context.ErrorForStatementFunctionAsExpression && function.ReturnType == typeof(void) && callerContext.Parent is ScriptExpression)
            {
                var firstToken = callerContext.FindFirstTerminal();
                throw new ScriptRuntimeException(callerContext.Span, $"The function `{firstToken}` is a statement and cannot be used within an expression.");
            }

            // We can't cache this array because it might be collect by the function
            // So we absolutely need to generate a new array everytime we call a function
            ScriptArray argumentValues;
            List<ScriptExpression> allArgumentsWithPipe = null;
            // Handle pipe arguments here
            if (isPipeCall)
            {
                var argCount = Math.Max(function.RequiredParameterCount, 1 + (arguments?.Count ?? 0));
                allArgumentsWithPipe = context.GetOrCreateListOfScriptExpressions(argCount);
                var pipeFrom = context.CurrentPipeArguments.Pop();
                argumentValues = new ScriptArray(argCount);
                allArgumentsWithPipe.Add(pipeFrom);
                if (arguments != null)
                {
                    allArgumentsWithPipe.AddRange(arguments);
                }

                arguments = allArgumentsWithPipe;
            }
            else
            {
                argumentValues = new ScriptArray(arguments?.Count ?? 0);
            }

            var needLocal = !(function is ScriptFunction func && func.HasParameters);
            object result = null;
            try
            {
                // Process direct arguments
                ulong argMask = 0;
                if (arguments != null)
                {
                    argMask = await ProcessArgumentsAsync(context, callerContext, arguments, function, scriptFunction, argumentValues).ConfigureAwait(false);
                }

                // Fill remaining argument default values
                var hasVariableParams = function.VarParamKind != ScriptVarParamKind.None;
                var requiredParameterCount = function.RequiredParameterCount;
                var parameterCount = function.ParameterCount;
                if (function.VarParamKind != ScriptVarParamKind.Direct)
                {
                    FillRemainingOptionalArguments(ref argMask, argumentValues.Count, parameterCount - 1, function, argumentValues);
                }

                // Check the required number of arguments
                var requiredMask = (1U << requiredParameterCount) - 1;
                argMask = argMask & requiredMask;
                // Create a span after the caller for missing arguments
                var afterCallerSpan = callerContext.Span;
                afterCallerSpan.Start = afterCallerSpan.End.NextColumn();
                afterCallerSpan.End = afterCallerSpan.End.NextColumn();
                if (argMask != requiredMask)
                {
                    int argCount = 0;
                    while (argMask != 0)
                    {
                        if ((argMask & 1) != 0)
                            argCount++;
                        argMask = argMask >> 1;
                    }

                    throw new ScriptRuntimeException(afterCallerSpan, $"Invalid number of arguments `{argCount}` passed to `{callerContext}` while expecting `{requiredParameterCount}` arguments");
                }

                if (!hasVariableParams && argumentValues.Count > parameterCount)
                {
                    if (argumentValues.Count > 0 && arguments != null && argumentValues.Count <= arguments.Count)
                    {
                        throw new ScriptRuntimeException(arguments[argumentValues.Count - 1].Span, $"Invalid number of arguments `{argumentValues.Count}` passed to `{callerContext}` while expecting `{parameterCount}` arguments");
                    }

                    throw new ScriptRuntimeException(afterCallerSpan, $"Invalid number of arguments `{argumentValues.Count}` passed to `{callerContext}` while expecting `{parameterCount}` arguments");
                }

                context.EnterFunction(callerContext);
                try
                {
                    result = await function.InvokeAsync(context, callerContext, argumentValues, blockDelegate).ConfigureAwait(false);
                }
                catch (ArgumentException ex)
                {
                    // Slow path to detect the argument index from the name if we can
                    var index = GetParameterIndexByName(function, ex.ParamName);
                    if (index >= 0 && arguments != null && index < arguments.Count)
                    {
                        throw new ScriptRuntimeException(arguments[index].Span, ex.Message);
                    }

                    throw;
                }
                catch (ScriptArgumentException ex)
                {
                    var index = ex.ArgumentIndex;
                    if (index >= 0 && arguments != null && index < arguments.Count)
                    {
                        throw new ScriptRuntimeException(arguments[index].Span, ex.Message);
                    }

                    throw;
                }
                finally
                {
                    context.ExitFunction(callerContext);
                }
            }
            finally
            {
                if (allArgumentsWithPipe != null)
                {
                    context.ReleaseListOfScriptExpressions(allArgumentsWithPipe);
                }
            }

            // Restore the flow state to none
            context.FlowState = ScriptFlowState.None;
            return result;
        }

        /// <summary>
                /// Call a custom function with the already resolved parameters.
                /// </summary>
                /// <param name = "context"></param>
                /// <param name = "callerContext"></param>
                /// <param name = "function"></param>
                /// <param name = "arguments"></param>
                /// <returns></returns>
        public static async ValueTask<object> CallAsync(TemplateContext context, ScriptNode callerContext, IScriptCustomFunction function, ScriptArray arguments)
        {
            if (context == null)
                throw new ArgumentNullException(nameof(context));
            if (callerContext == null)
                throw new ArgumentNullException(nameof(callerContext));
            if (function == null)
                throw new ArgumentNullException(nameof(function));
            if (arguments == null)
                throw new ArgumentNullException(nameof(arguments));
            var parameterCount = function.ParameterCount;
            var argumentValues = new ScriptArray();
            var span = callerContext.Span;
            // Fast path if we don't have complicated parameters to handle (direct call, same amount of arguments than expected parameters)
            if (function.VarParamKind == ScriptVarParamKind.None && parameterCount == arguments.Count)
            {
                for (int i = 0; i < parameterCount; i++)
                {
                    var arg = arguments[i];
                    var paramType = function.GetParameterInfo(i).ParameterType;
                    var value = context.ToObject(span, arg, paramType);
                    argumentValues.Add(value);
                }
            }
            else
            {
                // Otherwise we need to do a slow path
                ulong argMask = 0;
                foreach (var arg in arguments)
                {
                    int index = argumentValues.Count;
                    {
                        var paramType = function.GetParameterInfo(index).ParameterType;
                        var value = context.ToObject(span, arg, paramType);
                        SetArgumentValue(index, value, function, ref argMask, argumentValues, parameterCount);
                    }
                }

                FillRemainingOptionalArguments(ref argMask, argumentValues.Count, parameterCount - 1, function, argumentValues);
                int requiredParameterCount = function.RequiredParameterCount;
                // Check the required number of arguments
                var requiredMask = (1U << requiredParameterCount) - 1;
                argMask = argMask & requiredMask;
                // Create a span after the caller for missing arguments
                var afterCallerSpan = callerContext.Span;
                afterCallerSpan.Start = afterCallerSpan.End.NextColumn();
                afterCallerSpan.End = afterCallerSpan.End.NextColumn();
                if (argMask != requiredMask)
                {
                    int argCount = 0;
                    while (argMask != 0)
                    {
                        if ((argMask & 1) != 0)
                            argCount++;
                        argMask = argMask >> 1;
                    }

                    throw new ScriptRuntimeException(afterCallerSpan, $"Invalid number of arguments `{argCount}` passed to `{callerContext}` while expecting `{requiredParameterCount}` arguments");
                }
            }

            object result = null;
            context.EnterFunction(callerContext);
            try
            {
                result = await function.InvokeAsync(context, callerContext, argumentValues, null).ConfigureAwait(false);
            }
            catch (ArgumentException ex)
            {
                // Slow path to detect the argument index from the name if we can
                var index = GetParameterIndexByName(function, ex.ParamName);
                if (index >= 0 && arguments != null && index < arguments.Count)
                {
                    throw new ScriptRuntimeException(span, ex.Message);
                }

                throw;
            }
            catch (ScriptArgumentException ex)
            {
                var index = ex.ArgumentIndex;
                if (index >= 0 && arguments != null && index < arguments.Count)
                {
                    throw new ScriptRuntimeException(span, ex.Message);
                }

                throw;
            }
            finally
            {
                context.ExitFunction(callerContext);
            }

            // Restore the flow state to none
            context.FlowState = ScriptFlowState.None;
            return result;
        }

        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            // Invoke evaluate on the target, but don't automatically call the function as if it was a parameterless call.
            var targetFunction = await context.EvaluateAsync(Target, true).ConfigureAwait(false);
            // Throw an exception if the target function is null
            if (targetFunction == null)
            {
                if (context.EnableRelaxedFunctionAccess)
                {
                    return null;
                }

                throw new ScriptRuntimeException(Target.Span, $"The function `{Target}` was not found");
            }

            return await CallAsync(context, this, targetFunction, context.AllowPipeArguments, Arguments).ConfigureAwait(false);
        }

        private static async ValueTask<ulong> ProcessArgumentsAsync(TemplateContext context, ScriptNode callerContext, IReadOnlyList<ScriptExpression> arguments, IScriptCustomFunction function, ScriptFunction scriptFunction, ScriptArray argumentValues)
        {
            ulong argMask = 0;
            var parameterCount = function.ParameterCount;
            for (var argIndex = 0; argIndex < arguments.Count; argIndex++)
            {
                var argument = arguments[argIndex];
                int index = argumentValues.Count;
                object value;
                // Handle named arguments
                var namedArg = argument as ScriptNamedArgument;
                if (namedArg != null)
                {
                    var argName = namedArg.Name?.Name;
                    if (argName == null)
                    {
                        throw new ScriptRuntimeException(argument.Span, "Invalid null argument name");
                    }

                    index = GetParameterIndexByName(function, argName);
                    // In case of a ScriptFunction, we write the named argument into the ScriptArray directly
                    if (function.VarParamKind != ScriptVarParamKind.None)
                    {
                        if (index >= 0)
                        {
                        }
                        // We can't add an argument that is "size" for array
                        else if (argumentValues.CanWrite(argName))
                        {
                            argumentValues.TrySetValue(context, callerContext.Span, argName, await context.EvaluateAsync(namedArg).ConfigureAwait(false), false);
                            continue;
                        }
                        else
                        {
                            throw new ScriptRuntimeException(argument.Span, $"Cannot pass argument {argName} to function. This name is not supported by this function.");
                        }
                    }

                    if (index < 0)
                    {
                        index = argumentValues.Count;
                    }
                }

                if (function.IsParameterType<ScriptExpression>(index))
                {
                    value = namedArg != null ? namedArg.Value : argument;
                }
                else
                {
                    value = await context.EvaluateAsync(argument).ConfigureAwait(false);
                }

                // Handle parameters expansion for a function call when the operator ^ is used
                if (argument is ScriptUnaryExpression unaryExpression && unaryExpression.Operator == ScriptUnaryOperator.FunctionParametersExpand && !(value is ScriptExpression))
                {
                    var valueEnumerator = value as IEnumerable;
                    if (valueEnumerator != null)
                    {
                        foreach (var subValue in valueEnumerator)
                        {
                            var paramType = function.GetParameterInfo(argumentValues.Count).ParameterType;
                            var newValue = context.ToObject(callerContext.Span, subValue, paramType);
                            SetArgumentValue(index, newValue, function, ref argMask, argumentValues, parameterCount);
                            index++;
                        }

                        continue;
                    }
                }

                {
                    var paramType = function.GetParameterInfo(index).ParameterType;
                    value = context.ToObject(argument.Span, value, paramType);
                }

                SetArgumentValue(index, value, function, ref argMask, argumentValues, parameterCount);
            }

            return argMask;
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptIfStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var conditionValue = context.ToBool(Condition.Span, await context.EvaluateAsync(Condition).ConfigureAwait(false));
            return conditionValue ? await context.EvaluateAsync(Then).ConfigureAwait(false) : await context.EvaluateAsync(Else).ConfigureAwait(false);
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptImportStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var value = await context.EvaluateAsync(Expression).ConfigureAwait(false);
            if (value == null)
            {
                return null;
            }

            context.Import(Expression.Span, value);
            return null;
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptIncrementDecrementExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var increment = this.Operator == ScriptUnaryOperator.Increment ? 1 : -1;
            var value = Evaluate(context, this.Right.Span, ScriptUnaryOperator.Plus, await context.EvaluateAsync(this.Right).ConfigureAwait(false));
            var incrementedValue = ScriptBinaryExpression.Evaluate(context, this.Right.Span, ScriptBinaryOperator.Add, value, increment);
            await context.SetValueAsync(Right, incrementedValue).ConfigureAwait(false);
            return Post ? value : incrementedValue;
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptIndexerExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            return await context.GetValueAsync(this).ConfigureAwait(false);
        }

        private async ValueTask<object> GetOrSetValueAsync(TemplateContext context, object valueToSet, bool setter)
        {
            object value = null;
            var targetObject = await context.GetValueAsync(Target).ConfigureAwait(false);
            if (targetObject == null)
            {
                if (context.EnableRelaxedTargetAccess)
                {
                    return null;
                }
                else
                {
                    throw new ScriptRuntimeException(Target.Span, $"Object `{Target}` is null. Cannot access indexer: {this}"); // unit test: 130-indexer-accessor-error1.txt
                }
            }

            var index = await context.EvaluateAsync(Index).ConfigureAwait(false);
            if (index == null)
            {
                if (context.EnableNullIndexer)
                {
                    return null;
                }
                else
                {
                    throw new ScriptRuntimeException(Index.Span, $"Cannot access target `{Target}` with a null indexer: {this}"); // unit test: 130-indexer-accessor-error2.txt
                }
            }

            var listAccessor = context.GetListAccessor(targetObject);
            if (targetObject is IDictionary || (targetObject is IScriptObject && (listAccessor == null || index is string)) || listAccessor == null)
            {
                var accessor = context.GetMemberAccessor(targetObject);
                if (accessor.HasIndexer)
                {
                    var itemIndex = context.ToObject(Index.Span, index, accessor.IndexType);
                    if (setter)
                    {
                        if (!accessor.TrySetItem(context, Index.Span, targetObject, itemIndex, valueToSet))
                        {
                            throw new ScriptRuntimeException(Index.Span, $"Cannot set a value for the readonly member `{itemIndex}` in the indexer: {Target}['{itemIndex}']");
                        }
                    }
                    else
                    {
                        var result = accessor.TryGetItem(context, Index.Span, targetObject, itemIndex, out value);
                        if (!context.EnableRelaxedMemberAccess && !result)
                        {
                            throw new ScriptRuntimeException(Index.Span, $"Cannot access target `{Target}` with an indexer: {Index}");
                        }
                    }
                }
                else
                {
                    var indexAsString = context.ObjectToString(index);
                    if (setter)
                    {
                        if (!accessor.TrySetValue(context, Index.Span, targetObject, indexAsString, valueToSet))
                        {
                            throw new ScriptRuntimeException(Index.Span, $"Cannot set a value for the readonly member `{indexAsString}` in the indexer: {Target}['{indexAsString}']"); // unit test: 130-indexer-accessor-error3.txt
                        }
                    }
                    else
                    {
                        if (!accessor.TryGetValue(context, Index.Span, targetObject, indexAsString, out value))
                        {
                            var result = context.TryGetMember?.Invoke(context, Index.Span, targetObject, indexAsString, out value) ?? false;
                            if (!context.EnableRelaxedMemberAccess && !result)
                            {
                                throw new ScriptRuntimeException(Index.Span, $"Cannot access target `{Target}` with an indexer: {Index}");
                            }
                        }
                    }
                }
            }
            else
            {
                int i = context.ToInt(Index.Span, index);
                var length = listAccessor.GetLength(context, Target.Span, targetObject);
                // Allow negative index from the end of the array
                if (i < 0)
                {
                    i = length + i;
                }

                if (!context.EnableRelaxedIndexerAccess && (i < 0 || i >= length))
                {
                    throw new ScriptRuntimeException(Index.Span, $"The index {i} is out of bounds [0, {length}] on the `{Target}` with the indexer: {Index}");
                }

                if (i >= 0)
                {
                    if (setter)
                    {
                        listAccessor.SetValue(context, Index.Span, targetObject, i, valueToSet);
                    }
                    else
                    {
                        value = listAccessor.GetValue(context, Index.Span, targetObject, i);
                    }
                }
            }

            return value;
        }

        public async ValueTask<object> GetValueAsync(TemplateContext context)
        {
            return await GetOrSetValueAsync(context, null, false).ConfigureAwait(false);
        }

        public async ValueTask SetValueAsync(TemplateContext context, object valueToSet)
        {
            await GetOrSetValueAsync(context, valueToSet, true).ConfigureAwait(false);
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptIsEmptyExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            return await context.GetValueAsync(this).ConfigureAwait(false);
        }

        private async ValueTask<object> GetTargetObjectAsync(TemplateContext context, bool isSet)
        {
            var targetObject = await context.GetValueAsync(Target).ConfigureAwait(false);
            if (targetObject == null)
            {
                if (isSet || !context.EnableRelaxedMemberAccess)
                {
                    throw new ScriptRuntimeException(this.Span, $"Object `{this.Target}` is null. Cannot access property `empty?`");
                }
            }

            return targetObject;
        }

        public override async ValueTask<object> GetValueAsync(TemplateContext context)
        {
            var targetObject = await GetTargetObjectAsync(context, false).ConfigureAwait(false);
            return context.IsEmpty(Span, targetObject);
        }
    }

    /// <summary>
        /// Base class for a loop statement
        /// </summary>
    
#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    abstract partial class ScriptLoopStatementBase
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            // Notify the context that we enter a loop block (used for variable with scope Loop)
            object result = null;
            context.EnterLoop(this);
            try
            {
                result = await EvaluateImplAsync(context).ConfigureAwait(false);
            }
            finally
            {
                // Level scope block
                context.ExitLoop(this);
                if (context.FlowState != ScriptFlowState.Return)
                {
                    // Revert to flow state to none unless we have a return that must be handled at a higher level
                    context.FlowState = ScriptFlowState.None;
                }
            }

            return result;
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptMemberExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            return await context.GetValueAsync(this).ConfigureAwait(false);
        }

        private async ValueTask<object> GetTargetObjectAsync(TemplateContext context, bool isSet)
        {
            var targetObject = await context.GetValueAsync(Target).ConfigureAwait(false);
            if (targetObject == null)
            {
                if (isSet || (context.EnableRelaxedMemberAccess == false && DotToken.TokenType != TokenType.QuestionDot))
                {
                    throw new ScriptRuntimeException(this.Member.Span, $"Object `{this.Target}` is null. Cannot access member: {this}"); // unit test: 131-member-accessor-error1.txt
                }
            }

            return targetObject;
        }

        public virtual async ValueTask<object> GetValueAsync(TemplateContext context)
        {
            var targetObject = await GetTargetObjectAsync(context, false).ConfigureAwait(false);
            // In case TemplateContext.EnableRelaxedMemberAccess
            if (targetObject == null)
            {
                if (context.EnableRelaxedTargetAccess || DotToken.TokenType == TokenType.QuestionDot)
                {
                    return null;
                }

                throw new ScriptRuntimeException(this.Member.Span, $"Cannot get the member {this} for a null object.");
            }

            var accessor = context.GetMemberAccessor(targetObject);
            var memberName = this.Member.Name;
            object value;
            if (!accessor.TryGetValue(context, Member.Span, targetObject, memberName, out value))
            {
                var result = context.TryGetMember?.Invoke(context, Member.Span, targetObject, memberName, out value);
                if (!context.EnableRelaxedMemberAccess && (!result.HasValue || !result.Value))
                {
                    throw new ScriptRuntimeException(this.Member.Span, $"Cannot get member with name {memberName}."); // unit test: 132-member-accessor-error2.txt
                }
            }

            return value;
        }

        public virtual async ValueTask SetValueAsync(TemplateContext context, object valueToSet)
        {
            var targetObject = await GetTargetObjectAsync(context, true).ConfigureAwait(false);
            var accessor = context.GetMemberAccessor(targetObject);
            var memberName = this.Member.Name;
            if (!accessor.TrySetValue(context, this.Member.Span, targetObject, memberName, valueToSet))
            {
                throw new ScriptRuntimeException(this.Member.Span, $"Cannot set a value for the readonly member: {this}"); // unit test: 132-member-accessor-error3.txt
            }
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptNamedArgument
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            if (Value != null)
                return await context.EvaluateAsync(Value).ConfigureAwait(false);
            return true;
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptNestedExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            // A nested expression will reset the pipe arguments for the group
            context.PushPipeArguments();
            try
            {
                return await context.GetValueAsync(this).ConfigureAwait(false);
            }
            finally
            {
                if (context.CurrentPipeArguments != null)
                {
                    context.PopPipeArguments();
                }
            }
        }

        public async ValueTask<object> GetValueAsync(TemplateContext context)
        {
            return await context.EvaluateAsync(Expression).ConfigureAwait(false);
        }

        public async ValueTask SetValueAsync(TemplateContext context, object valueToSet)
        {
            await context.SetValueAsync(Expression, valueToSet).ConfigureAwait(false);
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptObjectInitializerExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var obj = new ScriptObject();
            context.PushGlobalOnly(obj);
            try
            {
                foreach (var member in Members)
                {
                    await member.EvaluateAsync(context).ConfigureAwait(false);
                }
            }
            finally
            {
                context.PopGlobalOnly();
            }

            return obj;
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptObjectMember
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var variable = Name as ScriptVariable;
            var literal = Name as ScriptLiteral;
            var name = variable?.Name ?? literal?.Value?.ToString();
            context.CurrentGlobal.TrySetValue(context, Span, name, await context.EvaluateAsync(Value).ConfigureAwait(false), false);
            return null;
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptPage
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            context.FlowState = ScriptFlowState.None;
            try
            {
                return await context.EvaluateAsync(Body).ConfigureAwait(false);
            }
            finally
            {
                context.FlowState = ScriptFlowState.None;
            }
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptPipeCall
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            bool newPipe = context.CurrentPipeArguments == null;
            try
            {
                // Push a new pipe arguments
                if (newPipe)
                    context.PushPipeArguments();
                context.CurrentPipeArguments.Push(From);
                var result = await context.EvaluateAsync(To).ConfigureAwait(false);
                // If the result returns by the evaluation is a function and we haven't yet consumed the pipe argument
                // that means that we need to evaluate this function with the actual pipe arguments.
                if (result is IScriptCustomFunction && context.CurrentPipeArguments.Count > 0 && context.CurrentPipeArguments.Peek() == From)
                {
                    result = await ScriptFunctionCall.CallAsync(context, To, result, true, null).ConfigureAwait(false);
                }

                // If we have still remaining arguments, it is likely that the destination expression is not a function
                // so pipe arguments were not picked up and this is an error
                if (context.CurrentPipeArguments.Count > 0 && context.CurrentPipeArguments.Peek() == From)
                {
                    throw new ScriptRuntimeException(To.Span, $"Pipe expression destination `{To}` is not a valid function ");
                }

                return result;
            }
            catch
            {
                // If we have an exception clear all the pipe froms
                newPipe = false; // Don't try to clear the pipe
                context.ClearPipeArguments();
                throw;
            }
            finally
            {
                if (newPipe)
                {
                    context.PopPipeArguments();
                }
            }
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptRawStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            if (Text == null)
                return null;
            if (Text.Length > 0)
            {
                // If we are in the context of output, output directly to TemplateContext.Output
                if (context.EnableOutput)
                {
                    await context.WriteAsync(Text).ConfigureAwait(false);
                }
                else
                {
                    return Text.ToString();
                }
            }

            return null;
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptReturnStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var result = await context.EvaluateAsync(Expression).ConfigureAwait(false);
            //ensure that deferred array interators are evaluated before we lose context
            if (result is ScriptRange range)
                result = new ScriptArray(range);
            context.FlowState = ScriptFlowState.Return;
            return result;
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptTableRowStatement
    {
        protected override async ValueTask AfterLoopAsync(TemplateContext context)
        {
            await context.Write("</tr>").WriteLineAsync().ConfigureAwait(false);
        }

        protected override async ValueTask BeforeLoopAsync(TemplateContext context)
        {
            await context.WriteAsync("<tr class=\"row1\">").ConfigureAwait(false);
        }

        protected override async ValueTask<object> LoopItemAsync(TemplateContext context, LoopState state)
        {
            var localIndex = state.LocalIndex;
            var columnIndex = localIndex % _columnsCount;
            var tableRowLoopState = (TableRowLoopState)state;
            tableRowLoopState.Col = columnIndex;
            tableRowLoopState.ColFirst = columnIndex == 0;
            tableRowLoopState.ColLast = ((localIndex + 1) % _columnsCount) == 0;
            if (columnIndex == 0 && localIndex > 0)
            {
                await context.Write("</tr>").WriteAsync(context.NewLine).ConfigureAwait(false);
                var rowIndex = (localIndex / _columnsCount) + 1;
                await context.Write("<tr class=\"row").Write(rowIndex.ToString(CultureInfo.InvariantCulture)).WriteAsync("\">").ConfigureAwait(false);
            }

            await context.Write("<td class=\"col").Write((columnIndex + 1).ToString(CultureInfo.InvariantCulture)).WriteAsync("\">").ConfigureAwait(false);
            var result = await base.LoopItemAsync(context, state).ConfigureAwait(false);
            await context.WriteAsync("</td>").ConfigureAwait(false);
            return result;
        }

        protected override async ValueTask ProcessArgumentAsync(TemplateContext context, ScriptNamedArgument argument)
        {
            _columnsCount = 1;
            if (argument.Name?.Name == "cols")
            {
                _columnsCount = context.ToInt(argument.Value.Span, await context.EvaluateAsync(argument.Value).ConfigureAwait(false));
                if (_columnsCount <= 0)
                {
                    _columnsCount = 1;
                }

                return;
            }

            await base.ProcessArgumentAsync(context, argument).ConfigureAwait(false);
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptThisExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            return await context.GetValueAsync(this).ConfigureAwait(false);
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptUnaryExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            if (Operator == ScriptUnaryOperator.FunctionAlias)
            {
                return await context.EvaluateAsync(Right, true).ConfigureAwait(false);
            }

            var value = await context.EvaluateAsync(Right).ConfigureAwait(false);
            return Evaluate(context, Right.Span, Operator, value);
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    abstract partial class ScriptVariable
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            return await context.GetValueAsync((ScriptExpression)this).ConfigureAwait(false);
        }

        public virtual async ValueTask<object> GetValueAsync(TemplateContext context)
        {
            return await context.GetValueAsync(this).ConfigureAwait(false);
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptVariableGlobal
    {
        public override async ValueTask<object> GetValueAsync(TemplateContext context)
        {
            // Used a specialized overrides on contxet for ScriptVariableGlobal
            return await context.GetValueAsync(this).ConfigureAwait(false);
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptWhenStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var caseValue = context.PeekCase();
            foreach (var value in Values)
            {
                var whenValue = await context.EvaluateAsync(value).ConfigureAwait(false);
                var result = ScriptBinaryExpression.Evaluate(context, Span, ScriptBinaryOperator.CompareEqual, caseValue, whenValue);
                if (result is bool && (bool)result)
                {
                    return await context.EvaluateAsync(Body).ConfigureAwait(false);
                }
            }

            return await context.EvaluateAsync(Next).ConfigureAwait(false);
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptWhileStatement
    {
        protected override async ValueTask<object> EvaluateImplAsync(TemplateContext context)
        {
            var index = 0;
            object result = null;
            await BeforeLoopAsync(context).ConfigureAwait(false);
            var loopState = CreateLoopState();
            context.SetLoopVariable(ScriptVariable.WhileObject, loopState);
            while (context.StepLoop(this))
            {
                var conditionResult = context.ToBool(Condition.Span, await context.EvaluateAsync(Condition).ConfigureAwait(false));
                if (!conditionResult)
                {
                    break;
                }

                loopState.Index = index++;
                loopState.LocalIndex = index;
                loopState.IsLast = false;
                result = await LoopItemAsync(context, loopState).ConfigureAwait(false);
                if (!ContinueLoop(context))
                {
                    break;
                }
            }

            ;
            await AfterLoopAsync(context).ConfigureAwait(false);
            return result;
        }

        protected override async ValueTask<object> LoopItemAsync(TemplateContext context, LoopState state)
        {
            return await context.EvaluateAsync(Body).ConfigureAwait(false);
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptWithStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var target = await context.GetValueAsync(Name).ConfigureAwait(false);
            if (!(target is IScriptObject))
            {
                var targetName = target?.GetType().Name ?? "null";
                throw new ScriptRuntimeException(Name.Span, $"Invalid target property `{Name}` used for [with] statement. Must be a ScriptObject instead of `{targetName}`");
            }

            context.PushGlobal((IScriptObject)target);
            try
            {
                var result = await context.EvaluateAsync(Body).ConfigureAwait(false);
                return result;
            }
            finally
            {
                context.PopGlobal();
            }
        }
    }

#if SCRIBAN_PUBLIC
    public
#else
    internal
#endif
    partial class ScriptWrapStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            // Check that the Target is actually a function
            var functionCall = Target as ScriptFunctionCall;
            if (functionCall == null)
            {
                var parameterLessFunction = await context.EvaluateAsync(Target, true).ConfigureAwait(false);
                if (!(parameterLessFunction is IScriptCustomFunction))
                {
                    var targetPrettyName = ScriptSyntaxAttribute.Get(Target);
                    throw new ScriptRuntimeException(Target.Span, $"Expecting a direct function instead of the expression `{Target}/{targetPrettyName.TypeName}`");
                }

                context.BlockDelegates.Push(Body);
                return await ScriptFunctionCall.CallAsync(context, this, parameterLessFunction, false, null).ConfigureAwait(false);
            }

            context.BlockDelegates.Push(Body);
            return await context.EvaluateAsync(functionCall).ConfigureAwait(false);
        }
    }
}
#endif
