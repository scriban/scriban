//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Date:05/12/2020 08:05:42
//     Runtime Version:3.1.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#if !SCRIBAN_NO_ASYNC
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Scriban.Helpers;
using Scriban.Parsing;
using Scriban.Runtime;
using Scriban.Syntax;
using System.Numerics;
namespace Scriban
{
    /// <summary>
    /// Basic entry point class to parse templates and render them. For more advanced scenario, you should use <see cref="TemplateContext"/> directly.
    /// </summary>
    public partial class Template
    {

        /// <summary>
        /// Evaluates the template using the specified context. See remarks.
        /// </summary>
        /// <param name="context">The template context.</param>
        /// <param name="render"><c>true</c> to render the output to the <see cref="TemplateContext.Output"/></param>
        /// <exception cref="System.ArgumentNullException">If context is null</exception>
        /// <exception cref="System.InvalidOperationException">If the template <see cref="HasErrors"/>. Check the <see cref="Messages"/> property for more details</exception>
        private async ValueTask<object> EvaluateAndRenderAsync(TemplateContext context, bool render)
        {
            if (context == null) throw new ArgumentNullException(nameof(context));
            CheckErrors();

            // Make sure that we are using the same parserOptions
            if (SourceFilePath != null)
            {
                context.PushSourceFile(SourceFilePath);
            }

            try
            {
                context.UseScientific = LexerOptions.Lang == ScriptLang.Scientific;
                var result = await context.EvaluateAsync(Page).ConfigureAwait(false);
                if (render)
                {
                    if (Page != null && context.EnableOutput && result != null)
                    {
                        await context.WriteAsync(Page.Span, result).ConfigureAwait(false);
                    }
                }
                return result;
            }
            finally
            {
                if (SourceFilePath != null)
                {
                    context.PopSourceFile();
                }
            }
        }

        /// <summary>
        /// Evaluates the template using the specified context. See remarks.
        /// </summary>
        /// <param name="context">The template context.</param>
        /// <exception cref="System.ArgumentNullException">If context is null</exception>
        /// <exception cref="System.InvalidOperationException">If the template <see cref="HasErrors"/>. Check the <see cref="Messages"/> property for more details</exception>
        /// <returns>Returns the result of the last statement</returns>
        public async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var previousOutput = context.EnableOutput;
            try
            {
                context.UseScientific = LexerOptions.Lang == ScriptLang.Scientific;
                context.EnableOutput = false;
                return await EvaluateAndRenderAsync(context, false).ConfigureAwait(false);
            }
            finally
            {
                context.EnableOutput = previousOutput;
            }
        }

        /// <summary>
        /// Parse and evaluates a code only expression (without enclosing `{{` and `}}`) within the specified context.
        /// </summary>
        /// <param name="expression">A code only expression (without enclosing `{{` and `}}`)</param>
        /// <param name="context">The template context</param>
        /// <returns>The result of the evaluation of the expression</returns>
        public static async ValueTask<object> EvaluateAsync(string expression, TemplateContext context)
        {
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            var lexerOption = new LexerOptions() { Mode = ScriptMode.ScriptOnly };
            var template = Parse(expression, lexerOptions: lexerOption);
            return await template.EvaluateAsync(context).ConfigureAwait(false);
        }

        /// <summary>
        /// Evaluates the template using the specified context
        /// </summary>
        /// <param name="model">An object model to use with the evaluation.</param>
        /// <param name="memberRenamer">The member renamer used to import this .NET object and transitive objects. See member renamer documentation for more details.</param>
        /// <param name="memberFilter">The member filter used to filter members for .NET objects being accessed through the template, including the model being passed to this method.</param>
        /// <exception cref="System.InvalidOperationException">If the template <see cref="HasErrors"/>. Check the <see cref="Messages"/> property for more details</exception>
        /// <returns>Returns the result of the last statement</returns>
        public async ValueTask<object> EvaluateAsync(object model = null, MemberRenamerDelegate memberRenamer = null, MemberFilterDelegate memberFilter = null)
        {
            var scriptObject = new ScriptObject();
            if (model != null)
            {
                scriptObject.Import(model, renamer: memberRenamer, filter: memberFilter);
            }

            var context = new TemplateContext
            {
                EnableOutput = false,
                MemberRenamer = memberRenamer,
                MemberFilter = memberFilter,
                UseScientific = LexerOptions.Lang == ScriptLang.Scientific,
            };
            context.PushGlobal(scriptObject);
            var result = await EvaluateAsync(context).ConfigureAwait(false);
            context.PopGlobal();
            return result;
        }

        /// <summary>
        /// Parse and evaluates a code only expression (without enclosing `{{` and `}}`) within the specified context.
        /// </summary>
        /// <param name="expression">A code only expression (without enclosing `{{` and `}}`)</param>
        /// <param name="model">An object instance used as a model for evaluating this expression</param>
        /// <param name="memberRenamer">The member renamer used to import this .NET object and transitive objects. See member renamer documentation for more details.</param>
        /// <param name="memberFilter">The member filter used to filter members for .NET objects being accessed through the template, including the model being passed to this method.</param>
        /// <returns>The result of the evaluation of the expression</returns>
        public static async ValueTask<object> EvaluateAsync(string expression, object model, MemberRenamerDelegate memberRenamer = null, MemberFilterDelegate memberFilter = null)
        {
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            var lexerOption = new LexerOptions() { Mode = ScriptMode.ScriptOnly };
            var template = Parse(expression, lexerOptions: lexerOption);
            return await template.EvaluateAsync(model, memberRenamer, memberFilter).ConfigureAwait(false);
        }

        /// <summary>
        /// Renders this template using the specified context. See remarks.
        /// </summary>
        /// <param name="context">The template context.</param>
        /// <exception cref="System.ArgumentNullException">If context is null</exception>
        /// <exception cref="System.InvalidOperationException">If the template <see cref="HasErrors"/>. Check the <see cref="Messages"/> property for more details</exception>
        /// <remarks>
        /// When using this method, the result of rendering this page is output to <see cref="TemplateContext.Output"/>
        /// </remarks>
        public async ValueTask<string> RenderAsync(TemplateContext context)
        {
            await EvaluateAndRenderAsync(context, true).ConfigureAwait(false);
            var result = context.Output.ToString();
            var output = context.Output as StringBuilderOutput;
            if (output != null)
            {
                output.Builder.Length = 0;
            }
            return result;
        }

        /// <summary>
        /// Renders this template using the specified object model.
        /// </summary>
        /// <param name="model">The object model.</param>
        /// <param name="memberRenamer">The member renamer used to import this .NET object and transitive objects. See member renamer documentation for more details.</param>
        /// <param name="memberFilter">The member filter used to filter members for .NET objects being accessed through the template, including the model being passed to this method.</param>
        /// <returns>A rendering result as a string </returns>
        public async ValueTask<string> RenderAsync(object model = null, MemberRenamerDelegate memberRenamer = null, MemberFilterDelegate memberFilter = null)
        {
            var scriptObject = new ScriptObject();
            if (model != null)
            {
                scriptObject.Import(model, renamer: memberRenamer, filter: memberFilter);
            }

            var context = LexerOptions.Lang == ScriptLang.Liquid ? new LiquidTemplateContext() : new TemplateContext();
            context.MemberRenamer = memberRenamer;
            context.MemberFilter = memberFilter;
            context.PushGlobal(scriptObject);
            return await RenderAsync(context).ConfigureAwait(false);
        }
    }
    /// <summary>
    /// The template context contains the state of the page, the model.
    /// </summary>
    public partial class TemplateContext
    {

        /// <summary>
        /// Evaluates the specified script node.
        /// </summary>
        /// <param name="scriptNode">The script node.</param>
        /// <param name="aliasReturnedFunction">if set to <c>true</c> and a function would be evaluated as part of this node, return the object function without evaluating it.</param>
        /// <returns>The result of the evaluation.</returns>
        public virtual async ValueTask<object> EvaluateAsync(ScriptNode scriptNode, bool aliasReturnedFunction)
        {
            if (scriptNode == null) return null;

            var previousFunctionCallState = _isFunctionCallDisabled;
            var previousLevel = _getOrSetValueLevel;
            var previousNode = CurrentNode;
            try
            {
                CurrentNode = scriptNode;
                _getOrSetValueLevel = 0;
                _isFunctionCallDisabled = aliasReturnedFunction;
                return await scriptNode.EvaluateAsync(this).ConfigureAwait(false);
            }
            catch (ScriptRuntimeException ex) when (this.RenderRuntimeException != null)
            {
                return this.RenderRuntimeException(ex);
            }
            finally
            {
                CurrentNode = previousNode;
                _getOrSetValueLevel = previousLevel;
                _isFunctionCallDisabled = previousFunctionCallState;
            }
        }

        /// <summary>
        /// Evaluates the specified script node.
        /// </summary>
        /// <param name="scriptNode">The script node.</param>
        /// <returns>The result of the evaluation.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public async ValueTask<object> EvaluateAsync(ScriptNode scriptNode)
        {
            return await EvaluateAsync(scriptNode, false).ConfigureAwait(false);
        }

        /// <summary>
        /// Evaluates the specified expression
        /// </summary>
        /// <param name="targetExpression">The expression to evaluate</param>
        /// <param name="valueToSet">A value to set in case of a setter</param>
        /// <param name="setter">true if this a setter</param>
        /// <returns>The value of the targetExpression</returns>
        private async ValueTask<object> GetOrSetValueAsync(ScriptExpression targetExpression, object valueToSet, bool setter)
        {
            object value = null;

            try
            {
                if (targetExpression is IScriptVariablePath nextPath)
                {
                    if (setter)
                    {
                        nextPath.SetValue(this, valueToSet);
                    }
                    else
                    {
                        value = nextPath.GetValue(this);
                    }
                }
                else if (!setter)
                {
                    value = await EvaluateAsync(targetExpression).ConfigureAwait(false);
                }
                else
                {
                    throw new ScriptRuntimeException(targetExpression.Span, $"Unsupported target expression for assignment."); // unit test: 105-assign-error1.txt
                }
            }
            catch (Exception readonlyException) when (_getOrSetValueLevel == 1 && !(readonlyException is ScriptRuntimeException))
            {
                throw new ScriptRuntimeException(targetExpression.Span, $"Unexpected exception while accessing target expression: {readonlyException.Message}", readonlyException);
            }

            // If the variable being returned is a function, we need to evaluate it
            // If function call is disabled, it will be only when returning the final object (level 0 of recursion)
            var allowFunctionCall = (_isFunctionCallDisabled && _getOrSetValueLevel > 1) || !_isFunctionCallDisabled;
            if (allowFunctionCall && ScriptFunctionCall.IsFunction(value))
            {
                // Allow to pipe arguments only for top level returned function
                value = await ScriptFunctionCall.CallAsync(this, targetExpression, value, _getOrSetValueLevel == 1, null).ConfigureAwait(false);
            }

            return value;
        }

        /// <summary>
        /// Gets the value from the specified expression using the current <see cref="ScriptObject"/> bound to the model context.
        /// </summary>
        /// <param name="target">The expression</param>
        /// <returns>The value of the expression</returns>
        public async ValueTask<object> GetValueAsync(ScriptExpression target)
        {
            _getOrSetValueLevel++;
            try
            {
                return await GetOrSetValueAsync(target, null, false).ConfigureAwait(false);
            }
            finally
            {
                _getOrSetValueLevel--;
            }
        }

        /// <summary>
        /// Sets the target expression with the specified value.
        /// </summary>
        /// <param name="target">The target expression.</param>
        /// <param name="value">The value.</param>
        /// <exception cref="System.ArgumentNullException">If target is null</exception>
        public async ValueTask SetValueAsync(ScriptExpression target, object value)
        {
            if (target == null) throw new ArgumentNullException(nameof(target));
            _getOrSetValueLevel++;
            try
            {
                await GetOrSetValueAsync(target, value, true).ConfigureAwait(false);
            }
            finally
            {
                _getOrSetValueLevel--;
            }
        }

        /// <summary>
        /// Writes the text to the current <see cref="Output"/>
        /// </summary>
        /// <param name="text">The text.</param>
        /// <param name="startIndex">The zero-based position of the substring of text</param>
        /// <param name="count">The number of characters to output starting at <paramref name="startIndex"/> position from the text</param>
        public async ValueTask<TemplateContext> WriteAsync(string text, int startIndex, int count)
        {
            if (text != null)
            {
                // Indented text
                if (CurrentIndent != null)
                {
                    var index = startIndex;
                    var indexEnd = startIndex + count;

                    while (index < indexEnd)
                    {
                        // Write indents if necessary
                        if (_previousTextWasNewLine)
                        {
                            await Output.WriteAsync(CurrentIndent, 0, CurrentIndent.Length, CancellationToken).ConfigureAwait(false);
                            _previousTextWasNewLine = false;
                        }

                        var newLineIndex = text.IndexOf('\n', index);
                        if (newLineIndex < 0)
                        {
                            await Output.WriteAsync(text, index, indexEnd - index, CancellationToken).ConfigureAwait(false);
                            break;
                        }

                        // We output the new line
                        await Output.WriteAsync(text, index, newLineIndex - index + 1, CancellationToken).ConfigureAwait(false);
                        index = newLineIndex + 1;
                        _previousTextWasNewLine = true;
                    }
                }
                else
                {
                    await Output.WriteAsync(text, startIndex, count, CancellationToken).ConfigureAwait(false);
                }
            }

            return this;
        }

        /// <summary>
        /// Writes the text to the current <see cref="Output"/>
        /// </summary>
        /// <param name="text">The text.</param>
        public async ValueTask<TemplateContext> WriteAsync(string text)
        {
            if (text != null)
            {
                await WriteAsync(text, 0, text.Length).ConfigureAwait(false);
            }
            return this;
        }

        /// <summary>
        /// Writes the text to the current <see cref="Output"/>
        /// </summary>
        /// <param name="slice">The text.</param>
        public async ValueTask<TemplateContext> WriteAsync(ScriptStringSlice slice)
        {
            await WriteAsync(slice.FullText, slice.Index, slice.Length).ConfigureAwait(false);
            return this;
        }

        /// <summary>
        /// Writes an object value to the current <see cref="Output"/>.
        /// </summary>
        /// <param name="span">The span of the object to render.</param>
        /// <param name="textAsObject">The text as object.</param>
        public virtual async ValueTask<TemplateContext> WriteAsync(SourceSpan span, object textAsObject)
        {
            if (textAsObject != null)
            {
                var text = ObjectToString(textAsObject);
                await WriteAsync(text).ConfigureAwait(false);
            }
            return this;
        }

        /// <summary>
        /// Writes the a new line to the current <see cref="Output"/>
        /// </summary>
        public async ValueTask<TemplateContext> WriteLineAsync()
        {
            await WriteAsync(NewLine).ConfigureAwait(false);
            return this;
        }
    }
}

namespace Scriban.Functions
{
    /// <summary>
    /// The include function available through the function 'include' in scriban.
    /// </summary>
    public sealed partial class IncludeFunction
    {

        public async ValueTask<object> InvokeAsync(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement)
        {
            if (arguments.Count == 0)
            {
                throw new ScriptRuntimeException(callerContext.Span, "Expecting at least the name of the template to include for the <include> function");
            }

            var templateName = context.ObjectToString(arguments[0]);

            // If template name is empty, throw an exception
            if (string.IsNullOrEmpty(templateName))
            {
                // In a liquid template context, we let an include to continue without failing
                if (context is LiquidTemplateContext)
                {
                    return null;
                }
                throw new ScriptRuntimeException(callerContext.Span, $"Include template name cannot be null or empty");
            }

            var templateLoader = context.TemplateLoader;
            if (templateLoader == null)
            {
                throw new ScriptRuntimeException(callerContext.Span, $"Unable to include <{templateName}>. No TemplateLoader registered in TemplateContext.TemplateLoader");
            }

            string templatePath;

            try
            {
                templatePath = templateLoader.GetPath(context, callerContext.Span, templateName);
            }
            catch (Exception ex) when (!(ex is ScriptRuntimeException))
            {
                throw new ScriptRuntimeException(callerContext.Span, $"Unexpected exception while getting the path for the include name `{templateName}`", ex);
            }
            // If template path is empty (probably because template doesn't exist), throw an exception
            if (templatePath == null)
            {
                throw new ScriptRuntimeException(callerContext.Span, $"Include template path is null for `{templateName}");
            }

            string indent = null;

            // Handle indent
            if (context.IndentWithInclude)
            {
                // Find the statement for the include
                var current = callerContext.Parent;
                while (current != null && !(current is ScriptStatement))
                {
                    current = current.Parent;
                }

                // Find the RawStatement preceding this include
                ScriptNode childNode = null;
                bool shouldContinue = true;
                while (shouldContinue && current != null)
                {
                    if (current is ScriptList<ScriptStatement> statementList && childNode is ScriptStatement childStatement)
                    {
                        var indexOf = statementList.IndexOf(childStatement);

                        // Case for first indent, if it is not the first statement in the doc
                        // it's not a valid indent
                        if (indent != null && indexOf > 0)
                        {
                            indent = null;
                            break;
                        }

                        for (int i = indexOf - 1; i >= 0; i--)
                        {
                            var previousStatement = statementList[i];
                            if (previousStatement is ScriptEscapeStatement escapeStatement && escapeStatement.IsEntering)
                            {
                                if (i > 0 && statementList[i - 1] is ScriptRawStatement rawStatement)
                                {

                                    var text = rawStatement.Text;
                                    for (int j = text.Length - 1; j >= 0; j--)
                                    {
                                        var c = text[j];
                                        if (c == '\n')
                                        {
                                            shouldContinue = false;
                                            indent = text.Substring(j + 1);
                                            break;
                                        }

                                        if (!char.IsWhiteSpace(c))
                                        {
                                            shouldContinue = false;
                                            break;
                                        }

                                        if (j == 0)
                                        {
                                            // We have a raw statement that has only white spaces
                                            // It could be the first raw statement of the document
                                            // so we continue but we handle it later
                                            indent = text.ToString();
                                        }
                                    }
                                }
                                else
                                {
                                    shouldContinue = false;
                                }

                                break;
                            }
                        }
                    }

                    childNode = current;
                    current = childNode.Parent;
                }

                if (string.IsNullOrEmpty(indent))
                {
                    indent = null;
                }
            }


            // Compute a new parameters for the include
            var newParameters = new ScriptArray(arguments.Count - 1);
            for (int i = 1; i < arguments.Count; i++)
            {
                newParameters[i] = arguments[i];
            }

            context.SetValue(ScriptVariable.Arguments, newParameters, true);

            Template template;

            if (!context.CachedTemplates.TryGetValue(templatePath, out template))
            {

                string templateText;
                try
                {
                    templateText = await templateLoader.LoadAsync(context, callerContext.Span, templatePath).ConfigureAwait(false);
                }
                catch (Exception ex) when (!(ex is ScriptRuntimeException))
                {
                    throw new ScriptRuntimeException(callerContext.Span, $"Unexpected exception while loading the include `{templateName}` from path `{templatePath}`", ex);
                }

                if (templateText == null)
                {
                    throw new ScriptRuntimeException(callerContext.Span, $"The result of including `{templateName}->{templatePath}` cannot be null");
                }

                // Clone parser options
                var parserOptions = context.TemplateLoaderParserOptions;
                var lexerOptions = context.TemplateLoaderLexerOptions;
                template = Template.Parse(templateText, templatePath, parserOptions, lexerOptions);

                // If the template has any errors, throw an exception
                if (template.HasErrors)
                {
                    throw new ScriptParserRuntimeException(callerContext.Span, $"Error while parsing template `{templateName}` from `{templatePath}`", template.Messages);
                }

                context.CachedTemplates.Add(templatePath, template);
            }

            // Make sure that we cannot recursively include a template

            context.PushOutput();
            object result = null;
            context.EnterRecursive(callerContext);
            var previousIndent = context.CurrentIndent;
            context.CurrentIndent = indent;
            try
            {
                result = await template.RenderAsync(context).ConfigureAwait(false);
            }
            finally
            {
                context.ExitRecursive(callerContext);
                context.PopOutput();
                context.CurrentIndent = previousIndent;
            }

            return result;
        }
    }
}

namespace Scriban.Runtime
{
    public abstract partial class DynamicCustomFunction
    {



        protected async ValueTask<ArgumentValue> GetValueFromNamedArgumentAsync(TemplateContext context, ScriptNode callerContext, ScriptNamedArgument namedArg)
        {
            for (int j = 0; j < Parameters.Length; j++)
            {
                var arg = Parameters[j];
                if (arg.Name == namedArg.Name.Name)
                {
                    return new ArgumentValue(j, arg.ParameterType, await context.EvaluateAsync(namedArg).ConfigureAwait(false));
                }
            }
            throw new ScriptRuntimeException(callerContext.Span, $"Invalid argument `{namedArg.Name}` not found for function `{callerContext}`");
        }

    }

    /// <summary>
    /// Extensions for <see cref="IScriptOutput"/>
    /// </summary>
    public static partial class ScriptOutputExtensions
    {
        public static async ValueTask WriteAsync(this IScriptOutput scriptOutput, string text, CancellationToken cancellationToken)
        {
            if (text == null) throw new ArgumentNullException(nameof(text));
            await scriptOutput.WriteAsync(text, 0, text.Length, cancellationToken).ConfigureAwait(false);
        }

        public static async ValueTask WriteAsync(this IScriptOutput scriptOutput, ScriptStringSlice text, CancellationToken cancellationToken)
        {
            if (text.FullText == null) throw new ArgumentNullException(nameof(text));
            if (text.Length == 0) return;
            await scriptOutput.WriteAsync(text.FullText, text.Index, text.Length, cancellationToken).ConfigureAwait(false);
        }
    }
}
namespace Scriban.Syntax
{
    /// <summary>
        /// Used to rewrite a function call expression at evaluation time based
        /// on the arguments required by a function. Used by scientific mode scripting.
        /// </summary>
    internal partial class ScientificFunctionCallRewriter
    {
        private async ValueTask<ScriptExpression> RewriteAsync(TemplateContext context, int precedence, bool expectingExpression = false)
        {
            ScriptExpression leftValue = null;
            while (_index < Count)
            {
                ScriptExpression nextExpression = this[_index];
                // leftValue (*/^%)
                if (nextExpression is ScriptArgumentBinary bin)
                {
                    if (leftValue == null)
                    {
                        throw new ScriptRuntimeException(nextExpression.Span, precedence == 0 ? "This operator cannot be after a function call." : "This operator cannot be applied here.");
                    }

                    // Power has higher precedence than */%
                    var newPrecedence = Parser.GetDefaultBinaryOperatorPrecedence(bin.Operator);
                    if (newPrecedence <= precedence) // if new operator has lower precedence than previous, exit
                    {
                        break;
                    }

                    var rightArgExpr = this[_index + 1];
                    if (rightArgExpr is IScriptVariablePath)
                    {
                        var rightArg = await context.EvaluateAsync(rightArgExpr, true).ConfigureAwait(false);
                        if (rightArg is IScriptCustomFunction function)
                        {
                            var maxArg = function.RequiredParameterCount;
                            if (maxArg >= 1 && PrecedenceTopLevel != precedence)
                            {
                                break;
                            }
                        }
                    }

                    // Skip the binary argument
                    _index++;
                    var rightValue = await RewriteAsync(context, newPrecedence).ConfigureAwait(false);
                    leftValue = new ScriptBinaryExpression()
                    { Left = leftValue, Operator = bin.Operator, OperatorToken = bin.Operator.ToToken(), Right = rightValue, };
                    continue;
                }

                object result = null;
                if (!expectingExpression && nextExpression is IScriptVariablePath)
                {
                    var restoreStrictVariables = context.StrictVariables;
                    // Don't fail on trying to lookup for a variable
                    context.StrictVariables = false;
                    try
                    {
                        result = await context.EvaluateAsync(nextExpression, true).ConfigureAwait(false);
                    }
                    catch (ScriptRuntimeException) when (IgnoreExceptions)
                    {
                        // ignore any exceptions during trial evaluating as we could try to evaluate
                        // variable that aren't setup
                    }
                    finally
                    {
                        context.StrictVariables = restoreStrictVariables;
                    }

                    // If one argument is a function, the remaining arguments
                    if (result is IScriptCustomFunction function)
                    {
                        var maxArg = function.RequiredParameterCount != 0 ? function.RequiredParameterCount : function.ParameterCount > 0 ? 1 : 0;
                        if (maxArg > 0)
                        {
                            if (PrecedenceTopLevel == precedence || leftValue == null)
                            {
                                var functionCall = new ScriptFunctionCall { Target = (ScriptExpression)nextExpression.Clone(), ExplicitCall = true };
                                _index++;
                                var isExpectingExpression = function.IsParameterType<ScriptExpression>(0);
                                if (_index == Count)
                                {
                                    throw new ScriptRuntimeException(nextExpression.Span, "The function is expecting a parameter");
                                }

                                var arg = await RewriteAsync(context, 0, isExpectingExpression).ConfigureAwait(false);
                                functionCall.Arguments.Add(arg);
                                if (leftValue == null)
                                {
                                    leftValue = functionCall;
                                }
                                else
                                {
                                    leftValue = new ScriptBinaryExpression()
                                    { Left = leftValue, Operator = ScriptBinaryOperator.Multiply, OperatorToken = ScriptToken.Star(), Right = functionCall, };
                                }

                                continue;
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                }

                {
                    if (leftValue == null)
                    {
                        leftValue = (ScriptExpression)nextExpression.Clone();
                        _index++;
                    }
                    else
                    {
                        int precedenceOfImplicitMultiply = result is IScriptCustomImplicitMultiplyPrecedence ? PrecedenceOfMultiply : PrecedenceOfMultiply + 1;
                        if (precedenceOfImplicitMultiply <= precedence)
                        {
                            break;
                        }

                        // Implicit  the binary argument
                        var rightValue = await RewriteAsync(context, precedenceOfImplicitMultiply).ConfigureAwait(false);
                        if (rightValue is ScriptLiteral)
                        {
                            throw new ScriptRuntimeException(rightValue.Span, "Cannot use a literal on the right side of an implicit multiplication.");
                        }

                        leftValue = new ScriptBinaryExpression()
                        { Left = leftValue, Operator = ScriptBinaryOperator.Multiply, OperatorToken = ScriptToken.Star(), Right = rightValue, };
                    }
                }
            }

            return leftValue;
        }

        public async ValueTask<ScriptExpression> RewriteAsync(TemplateContext context, ScriptNode parent)
        {
            _parent = parent;
            _index = 0;
            var node = await RewriteAsync(context, PrecedenceTopLevel).ConfigureAwait(false);
            if (node.Parent == null)
            {
                node.Parent = _parent?.Parent;
            }

            return node;
        }
    }

    public partial class ScriptArrayInitializerExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var scriptArray = new ScriptArray();
            foreach (var value in Values)
            {
                var valueEval = await context.EvaluateAsync(value).ConfigureAwait(false);
                scriptArray.Add(valueEval);
            }

            return scriptArray;
        }
    }

    public partial class ScriptAssignExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var valueObject = await context.EvaluateAsync(Value).ConfigureAwait(false);
            await context.SetValueAsync(Target, valueObject).ConfigureAwait(false);
            return null;
        }
    }

    public partial class ScriptBinaryExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var leftValue = await context.EvaluateAsync(Left).ConfigureAwait(false);
            switch (Operator)
            {
                case ScriptBinaryOperator.And:
                    {
                        var leftBoolValue = context.ToBool(Left.Span, leftValue);
                        if (!leftBoolValue)
                            return false;
                        var rightValue = await context.EvaluateAsync(Right).ConfigureAwait(false);
                        var rightBoolValue = context.ToBool(Right.Span, rightValue);
                        return leftBoolValue && rightBoolValue;
                    }

                case ScriptBinaryOperator.Or:
                    {
                        var leftBoolValue = context.ToBool(Left.Span, leftValue);
                        if (leftBoolValue)
                            return true;
                        var rightValue = await context.EvaluateAsync(Right).ConfigureAwait(false);
                        return context.ToBool(Right.Span, rightValue);
                    }

                default:
                    {
                        var rightValue = await context.EvaluateAsync(Right).ConfigureAwait(false);
                        return Evaluate(context, OperatorToken?.Span ?? Span, Operator, Left.Span, leftValue, Right.Span, rightValue);
                    }
            }
        }
    }

    public partial class ScriptBlockStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            object result = null;
            var statements = Statements;
            for (int i = 0; i < statements.Count; i++)
            {
                var statement = statements[i];
                // Throws a cancellation
                context.CheckAbort();
                if (statement.CanSkipEvaluation)
                {
                    continue;
                }

                result = await context.EvaluateAsync(statement).ConfigureAwait(false);
                // Top-level assignment expression don't output anything
                if (!statement.CanOutput)
                {
                    result = null;
                }
                else if (result != null && context.FlowState != ScriptFlowState.Return && context.EnableOutput)
                {
                    await context.WriteAsync(Span, result).ConfigureAwait(false);
                    result = null;
                }

                // If flow state is different, we need to exit this loop
                if (context.FlowState != ScriptFlowState.None)
                {
                    break;
                }
            }

            return result;
        }
    }

    public partial class ScriptCaptureStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            // unit test: 230-capture-statement.txt
            context.PushOutput();
            try
            {
                await context.EvaluateAsync(Body).ConfigureAwait(false);
            }
            finally
            {
                var result = context.PopOutput();
                await context.SetValueAsync(Target, result).ConfigureAwait(false);
            }

            return null;
        }
    }

    public partial class ScriptCaseStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var caseValue = await context.EvaluateAsync(Value).ConfigureAwait(false);
            context.PushCase(caseValue);
            try
            {
                return await context.EvaluateAsync(Body).ConfigureAwait(false);
            }
            finally
            {
                context.PopCase();
            }
        }
    }

    public partial class ScriptElseStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            return await context.EvaluateAsync(Body).ConfigureAwait(false);
        }
    }

    public partial class ScriptExpressionStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var result = await context.EvaluateAsync(Expression).ConfigureAwait(false);
            // This code is necessary for wrap to work
            var codeDelegate = result as ScriptNode;
            if (codeDelegate != null)
            {
                return await context.EvaluateAsync(codeDelegate).ConfigureAwait(false);
            }

            return result;
        }
    }

    public partial class ScriptForStatement
    {
        protected override async ValueTask<object> EvaluateImplAsync(TemplateContext context)
        {
            var loopIterator = await context.EvaluateAsync(Iterator).ConfigureAwait(false);
            var list = loopIterator as IList;
            if (list == null)
            {
                var iterator = loopIterator as IEnumerable;
                if (iterator != null)
                {
                    list = new ScriptArray(iterator);
                }
            }

            if (list != null)
            {
                object loopResult = null;
                object previousValue = null;
                bool reversed = false;
                int startIndex = 0;
                int limit = list.Count;
                if (NamedArguments != null)
                {
                    foreach (var option in NamedArguments)
                    {
                        switch (option.Name.Name)
                        {
                            case "offset":
                                startIndex = context.ToInt(option.Value.Span, await context.EvaluateAsync(option.Value).ConfigureAwait(false));
                                break;
                            case "reversed":
                                reversed = true;
                                break;
                            case "limit":
                                limit = context.ToInt(option.Value.Span, await context.EvaluateAsync(option.Value).ConfigureAwait(false));
                                break;
                            default:
                                await ProcessArgumentAsync(context, option).ConfigureAwait(false);
                                break;
                        }
                    }
                }

                var endIndex = Math.Min(limit + startIndex, list.Count) - 1;
                var index = reversed ? endIndex : startIndex;
                var dir = reversed ? -1 : 1;
                bool isFirst = true;
                int i = 0;
                await BeforeLoopAsync(context).ConfigureAwait(false);
                var loopState = CreateLoopState();
                context.SetValue(GetLoopVariable(context), loopState);
                loopState.Length = list.Count;
                bool enteredLoop = false;
                while (!reversed && index <= endIndex || reversed && index >= startIndex)
                {
                    enteredLoop = true;
                    if (!context.StepLoop(this))
                    {
                        return null;
                    }

                    // We update on next run on previous value (in order to handle last)
                    var value = list[index];
                    bool isLast = reversed ? index == startIndex : index == endIndex;
                    loopState.Index = index;
                    loopState.LocalIndex = i;
                    loopState.IsLast = isLast;
                    loopState.ValueChanged = isFirst || !Equals(previousValue, value);
                    await context.SetValueAsync(Variable, value).ConfigureAwait(false);
                    loopResult = await LoopItemAsync(context, loopState).ConfigureAwait(false);
                    if (!ContinueLoop(context))
                    {
                        break;
                    }

                    previousValue = value;
                    isFirst = false;
                    index += dir;
                    i++;
                }

                await AfterLoopAsync(context).ConfigureAwait(false);
                context.SetValue(ScriptVariable.Continue, index);
                if (!enteredLoop && Else != null)
                {
                    loopResult = await context.EvaluateAsync(Else).ConfigureAwait(false);
                }

                return loopResult;
            }

            if (loopIterator != null)
            {
                throw new ScriptRuntimeException(Iterator.Span, $"Unexpected type `{loopIterator.GetType()}` for iterator");
            }

            return null;
        }

        protected override async ValueTask<object> LoopItemAsync(TemplateContext context, LoopState state)
        {
            return await context.EvaluateAsync(Body).ConfigureAwait(false);
        }
    }

    public partial class ScriptFunction
    {
        public async ValueTask<object> InvokeAsync(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement)
        {
            if (HasParameters)
            {
                context.PushVariableScope(ScriptVariableScope.Global);
            }

            try
            {
                context.SetValue(ScriptVariable.Arguments, arguments, true);
                if (HasParameters)
                {
                    for (var i = 0; i < Parameters.Count; i++)
                    {
                        var arg = Parameters[i];
                        context.SetValue(arg, arguments[i]);
                    }
                }

                // Set the block delegate
                if (blockStatement != null)
                {
                    context.SetValue(ScriptVariable.BlockDelegate, blockStatement, true);
                }

                return await context.EvaluateAsync(Body).ConfigureAwait(false);
            }
            finally
            {
                if (HasParameters)
                {
                    context.PopVariableScope(ScriptVariableScope.Global);
                }
            }
        }
    }

    public partial class ScriptFunctionCall
    {
        public static async ValueTask<object> CallAsync(TemplateContext context, ScriptNode callerContext, object functionObject, bool processPipeArguments, IReadOnlyList<ScriptExpression> arguments)
        {
            if (context == null)
                throw new ArgumentNullException(nameof(context));
            // Pop immediately the block
            ScriptBlockStatement blockDelegate = null;
            if (context.BlockDelegates.Count > 0)
            {
                blockDelegate = context.BlockDelegates.Pop();
            }

            if (callerContext == null)
                throw new ArgumentNullException(nameof(callerContext));
            if (functionObject == null)
            {
                throw new ScriptRuntimeException(callerContext.Span, $"The target function `{callerContext}` is null");
            }

            var scriptFunction = functionObject as ScriptFunction;
            var function = functionObject as IScriptCustomFunction;
            if (function == null)
            {
                throw new ScriptRuntimeException(callerContext.Span, $"Invalid target function `{functionObject}` ({functionObject?.GetType().ScriptPrettyName()})");
            }

            if (function.ParameterCount >= MaximumParameterCount)
            {
                throw new ScriptRuntimeException(callerContext.Span, $"Out of range number of parameters {function.ParameterCount} for target function `{functionObject}`. The maximum number of parameters for a function is: {MaximumParameterCount}.");
            }

            // Generates an error only if the context is configured for it
            if (context.ErrorForStatementFunctionAsExpression && function.ReturnType == typeof(void) && callerContext.Parent is ScriptExpression)
            {
                var firstToken = callerContext.FindFirstTerminal();
                throw new ScriptRuntimeException(callerContext.Span, $"The function `{firstToken}` is a statement and cannot be used within an expression.");
            }

            // We can't cache this array because it might be collect by the function
            // So we absolutely need to generate a new array everytime we call a function
            ScriptArray argumentValues;
            List<ScriptExpression> allArgumentsWithPipe = null;
            // Handle pipe arguments here
            if (processPipeArguments && context.CurrentPipeArguments != null && context.CurrentPipeArguments.Count > 0)
            {
                var argCount = Math.Max(function.RequiredParameterCount, 1 + (arguments?.Count ?? 0));
                allArgumentsWithPipe = context.GetOrCreateListOfScriptExpressions(argCount);
                var pipeFrom = context.CurrentPipeArguments.Pop();
                argumentValues = context.GetOrCreateScriptArguments(argCount);
                allArgumentsWithPipe.Add(pipeFrom);
                if (arguments != null)
                {
                    allArgumentsWithPipe.AddRange(arguments);
                }

                arguments = allArgumentsWithPipe;
            }
            else
            {
                argumentValues = context.GetOrCreateScriptArguments(arguments?.Count ?? 0);
            }

            var needLocal = !(function is ScriptFunction func && func.HasParameters);
            object result = null;
            try
            {
                // Process direct arguments
                ulong argMask = 0;
                if (arguments != null)
                {
                    argMask = await ProcessArgumentsAsync(context, callerContext, arguments, function, scriptFunction, argumentValues).ConfigureAwait(false);
                }

                // Fill remaining argument default values
                var hasVariableParams = function.HasVariableParams;
                var requiredParameterCount = function.RequiredParameterCount;
                var parameterCount = function.ParameterCount;
                FillRemainingOptionalArguments(ref argMask, argumentValues.Count, parameterCount, function, argumentValues);
                // Check the required number of arguments
                var requiredMask = (1U << requiredParameterCount) - 1;
                argMask = argMask & requiredMask;
                if (argMask != requiredMask)
                {
                    int argCount = 0;
                    while (argMask != 0)
                    {
                        if ((argMask & 1) != 0)
                            argCount++;
                        argMask = argMask >> 1;
                    }

                    throw new ScriptRuntimeException(callerContext.Span, $"Invalid number of arguments `{argCount}` passed to `{callerContext}` while expecting `{requiredParameterCount}` arguments");
                }

                if (!hasVariableParams && argumentValues.Count > parameterCount)
                {
                    if (argumentValues.Count > 0 && arguments != null && argumentValues.Count <= arguments.Count)
                    {
                        throw new ScriptRuntimeException(arguments[argumentValues.Count - 1].Span, $"Invalid number of arguments `{argumentValues.Count}` passed to `{callerContext}` while expecting `{parameterCount}` arguments");
                    }

                    throw new ScriptRuntimeException(callerContext.Span, $"Invalid number of arguments `{argumentValues.Count}` passed to `{callerContext}` while expecting `{parameterCount}` arguments");
                }

                context.EnterFunction(callerContext, needLocal);
                try
                {
                    result = await function.InvokeAsync(context, callerContext, argumentValues, blockDelegate).ConfigureAwait(false);
                }
                catch (ArgumentException ex)
                {
                    // Slow path to detect the argument index from the name if we can
                    var index = GetParameterIndexByName(function, ex.ParamName);
                    if (index >= 0 && arguments != null && index < arguments.Count)
                    {
                        throw new ScriptRuntimeException(arguments[index].Span, ex.Message);
                    }

                    throw;
                }
                catch (ScriptArgumentException ex)
                {
                    var index = ex.ArgumentIndex;
                    if (index >= 0 && arguments != null && index < arguments.Count)
                    {
                        throw new ScriptRuntimeException(arguments[index].Span, ex.Message);
                    }

                    throw;
                }
                finally
                {
                    context.ExitFunction(needLocal);
                }
            }
            finally
            {
                if (allArgumentsWithPipe != null)
                {
                    context.ReleaseListOfScriptExpressions(allArgumentsWithPipe);
                }

                context.ReleaseScriptArguments(argumentValues);
            }

            // Restore the flow state to none
            context.FlowState = ScriptFlowState.None;
            return result;
        }

        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            // Double check if the expression can be rewritten
            var newExpression = await GetScientificExpressionAsync(context).ConfigureAwait(false);
            if (newExpression != this)
            {
                return await context.EvaluateAsync(newExpression).ConfigureAwait(false);
            }

            // Invoke evaluate on the target, but don't automatically call the function as if it was a parameterless call.
            var targetFunction = await context.EvaluateAsync(Target, true).ConfigureAwait(false);
            // Throw an exception if the target function is null
            if (targetFunction == null)
            {
                throw new ScriptRuntimeException(Target.Span, $"The function `{Target}` was not found");
            }

            return await CallAsync(context, this, targetFunction, context.AllowPipeArguments, Arguments).ConfigureAwait(false);
        }

        public async ValueTask<ScriptExpression> GetScientificExpressionAsync(TemplateContext context, bool ignoreExceptions = false)
        {
            // If we are in scientific mode and we have a function which takes arguments, and is not an explicit call (e.g sin(x) rather then sin x)
            // Then we need to rewrite the call to a proper expression.
            if (context.UseScientific && !ExplicitCall && Arguments.Count > 0)
            {
                var rewrite = new ScientificFunctionCallRewriter(1 + Arguments.Count)
                { IgnoreExceptions = ignoreExceptions };
                rewrite.Add(Target);
                rewrite.AddRange(Arguments);
                return await rewrite.RewriteAsync(context, this).ConfigureAwait(false);
            }

            return this;
        }

        private static async ValueTask<ulong> ProcessArgumentsAsync(TemplateContext context, ScriptNode callerContext, IReadOnlyList<ScriptExpression> arguments, IScriptCustomFunction function, ScriptFunction scriptFunction, ScriptArray argumentValues)
        {
            bool hasNamedArgument = false;
            ulong argMask = 0;
            var parameterCount = function.ParameterCount;
            for (var argIndex = 0; argIndex < arguments.Count; argIndex++)
            {
                var argument = arguments[argIndex];
                int index = argumentValues.Count;
                object value;
                // Handle named arguments
                var namedArg = argument as ScriptNamedArgument;
                if (namedArg != null)
                {
                    hasNamedArgument = true;
                    var argName = namedArg.Name?.Name;
                    if (argName == null)
                    {
                        throw new ScriptRuntimeException(argument.Span, "Invalid null argument name");
                    }

                    index = GetParameterIndexByName(function, argName);
                    // In case of a ScriptFunction, we write the named argument into the ScriptArray directly
                    if (scriptFunction != null)
                    {
                        if (function.HasVariableParams)
                        {
                            if (index >= 0)
                            {
                            }
                            // We can't add an argument that is "size" for array
                            else if (argumentValues.CanWrite(argName))
                            {
                                argumentValues.TrySetValue(context, callerContext.Span, argName, await context.EvaluateAsync(namedArg).ConfigureAwait(false), false);
                                continue;
                            }
                            else
                            {
                                throw new ScriptRuntimeException(argument.Span, $"Cannot pass argument {argName} to function. This name is not supported by this function.");
                            }
                        }
                    }

                    if (index < 0)
                    {
                        index = argumentValues.Count;
                    }
                }
                else if (hasNamedArgument)
                {
                    throw new ScriptRuntimeException(argument.Span, "Cannot pass this argument after a named argument");
                }

                if (function.IsParameterType<ScriptExpression>(index))
                {
                    value = namedArg != null ? namedArg.Value : argument;
                }
                else
                {
                    value = await context.EvaluateAsync(argument).ConfigureAwait(false);
                }

                // Handle parameters expansion for a function call when the operator ^ is used
                if (argument is ScriptUnaryExpression unaryExpression && unaryExpression.Operator == ScriptUnaryOperator.FunctionParametersExpand && !(value is ScriptExpression))
                {
                    var valueEnumerator = value as IEnumerable;
                    if (valueEnumerator != null)
                    {
                        foreach (var subValue in valueEnumerator)
                        {
                            if (argumentValues.Count < parameterCount)
                                argMask |= 1U << argumentValues.Count;
                            var paramType = function.GetParameterInfo(argumentValues.Count).ParameterType;
                            value = context.ToObject(callerContext.Span, value, paramType);
                            argumentValues.Add(subValue);
                        }

                        continue;
                    }
                }

                {
                    var paramType = function.GetParameterInfo(index).ParameterType;
                    value = context.ToObject(argument.Span, value, paramType);
                }

                if (index == argumentValues.Count)
                {
                    if (argumentValues.Count < parameterCount)
                        argMask |= 1U << argumentValues.Count;
                    argumentValues.Add(value);
                    continue;
                }

                // NamedArguments can index further, so we need to fill any intermediate argument values
                // with their default values.
                if (index > argumentValues.Count)
                {
                    FillRemainingOptionalArguments(ref argMask, argumentValues.Count, index, function, argumentValues);
                }

                if (index < parameterCount)
                    argMask |= 1U << index;
                argumentValues[index] = value;
            }

            return argMask;
        }
    }

    public partial class ScriptIfStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var conditionValue = context.ToBool(Condition.Span, await context.EvaluateAsync(Condition).ConfigureAwait(false));
            return conditionValue ? await context.EvaluateAsync(Then).ConfigureAwait(false) : await context.EvaluateAsync(Else).ConfigureAwait(false);
        }
    }

    public partial class ScriptImportStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var value = await context.EvaluateAsync(Expression).ConfigureAwait(false);
            if (value == null)
            {
                return null;
            }

            var scriptObject = value as ScriptObject;
            if (scriptObject == null)
            {
                throw new ScriptRuntimeException(Expression.Span, $"Unexpected value `{value.GetType()}` for import. Expecting an plain script object {{}}");
            }

            context.CurrentGlobal.Import(scriptObject);
            return null;
        }
    }

    public partial class ScriptIndexerExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            return await context.GetValueAsync(this).ConfigureAwait(false);
        }

        private async ValueTask<object> GetOrSetValueAsync(TemplateContext context, object valueToSet, bool setter)
        {
            object value = null;
            var targetObject = await context.GetValueAsync(Target).ConfigureAwait(false);
            if (targetObject == null)
            {
                if (context.EnableRelaxedTargetAccess)
                {
                    return null;
                }
                else
                {
                    throw new ScriptRuntimeException(Target.Span, $"Object `{Target}` is null. Cannot access indexer: {this}"); // unit test: 130-indexer-accessor-error1.txt
                }
            }

            var index = await context.EvaluateAsync(Index).ConfigureAwait(false);
            if (index == null)
            {
                if (context.EnableNullIndexer)
                {
                    return null;
                }
                else
                {
                    throw new ScriptRuntimeException(Index.Span, $"Cannot access target `{Target}` with a null indexer: {this}"); // unit test: 130-indexer-accessor-error2.txt
                }
            }

            var listAccessor = context.GetListAccessor(targetObject);
            if (targetObject is IDictionary || (targetObject is IScriptObject && listAccessor == null) || listAccessor == null)
            {
                var accessor = context.GetMemberAccessor(targetObject);
                var indexAsString = context.ObjectToString(index);
                if (setter)
                {
                    if (!accessor.TrySetValue(context, Span, targetObject, indexAsString, valueToSet))
                    {
                        throw new ScriptRuntimeException(Index.Span, $"Cannot set a value for the readonly member `{indexAsString}` in the indexer: {Target}['{indexAsString}']"); // unit test: 130-indexer-accessor-error3.txt
                    }
                }
                else
                {
                    if (!accessor.TryGetValue(context, Span, targetObject, indexAsString, out value))
                    {
                        var result = context.TryGetMember?.Invoke(context, Span, targetObject, indexAsString, out value) ?? false;
                        if (!context.EnableRelaxedMemberAccess && !result)
                        {
                            throw new ScriptRuntimeException(Target.Span, $"Cannot access target `{Target}` with an indexer: {Index}");
                        }
                    }
                }
            }
            else
            {
                int i = context.ToInt(Index.Span, index);
                var length = listAccessor.GetLength(context, Span, targetObject);
                // Allow negative index from the end of the array
                if (i < 0)
                {
                    i = length + i;
                }

                if (!context.EnableRelaxedIndexerAccess && (i < 0 || i >= length))
                {
                    throw new ScriptRuntimeException(Index.Span, $"The index {i} is out of bounds [0, {length}] on the `{Target}` with the indexer: {Index}");
                }

                if (i >= 0)
                {
                    if (setter)
                    {
                        listAccessor.SetValue(context, Span, targetObject, i, valueToSet);
                    }
                    else
                    {
                        value = listAccessor.GetValue(context, Span, targetObject, i);
                    }
                }
            }

            return value;
        }

        public async ValueTask<object> GetValueAsync(TemplateContext context)
        {
            return await GetOrSetValueAsync(context, null, false).ConfigureAwait(false);
        }

        public async ValueTask SetValueAsync(TemplateContext context, object valueToSet)
        {
            await GetOrSetValueAsync(context, valueToSet, true).ConfigureAwait(false);
        }
    }

    public partial class ScriptIsEmptyExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            return await context.GetValueAsync(this).ConfigureAwait(false);
        }

        private async ValueTask<object> GetTargetObjectAsync(TemplateContext context, bool isSet)
        {
            var targetObject = await context.GetValueAsync(Target).ConfigureAwait(false);
            if (targetObject == null)
            {
                if (isSet || !context.EnableRelaxedMemberAccess)
                {
                    throw new ScriptRuntimeException(this.Span, $"Object `{this.Target}` is null. Cannot access property `empty?`");
                }
            }

            return targetObject;
        }

        public override async ValueTask<object> GetValueAsync(TemplateContext context)
        {
            var targetObject = await GetTargetObjectAsync(context, false).ConfigureAwait(false);
            return context.IsEmpty(Span, targetObject);
        }
    }

    /// <summary>
        /// Base class for a loop statement
        /// </summary>
    public abstract partial class ScriptLoopStatementBase
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            // Notify the context that we enter a loop block (used for variable with scope Loop)
            object result = null;
            context.EnterLoop(this);
            try
            {
                result = await EvaluateImplAsync(context).ConfigureAwait(false);
            }
            finally
            {
                // Level scope block
                context.ExitLoop(this);
                if (context.FlowState != ScriptFlowState.Return)
                {
                    // Revert to flow state to none unless we have a return that must be handled at a higher level
                    context.FlowState = ScriptFlowState.None;
                }
            }

            return result;
        }
    }

    public partial class ScriptMemberExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            return await context.GetValueAsync(this).ConfigureAwait(false);
        }

        private async ValueTask<object> GetTargetObjectAsync(TemplateContext context, bool isSet)
        {
            var targetObject = await context.GetValueAsync(Target).ConfigureAwait(false);
            if (targetObject == null)
            {
                if (isSet || !context.EnableRelaxedMemberAccess)
                {
                    throw new ScriptRuntimeException(this.Span, $"Object `{this.Target}` is null. Cannot access member: {this}"); // unit test: 131-member-accessor-error1.txt
                }
            }

            return targetObject;
        }

        public virtual async ValueTask<object> GetValueAsync(TemplateContext context)
        {
            var targetObject = await GetTargetObjectAsync(context, false).ConfigureAwait(false);
            // In case TemplateContext.EnableRelaxedMemberAccess
            if (targetObject == null)
            {
                if (context.EnableRelaxedTargetAccess)
                {
                    return null;
                }

                throw new ScriptRuntimeException(this.Member.Span, $"Cannot get the member {this} for a null object.");
            }

            var accessor = context.GetMemberAccessor(targetObject);
            var memberName = this.Member.Name;
            object value;
            if (!accessor.TryGetValue(context, Span, targetObject, memberName, out value))
            {
                var result = context.TryGetMember?.Invoke(context, Span, targetObject, memberName, out value);
                if (!context.EnableRelaxedMemberAccess && (!result.HasValue || !result.Value))
                {
                    throw new ScriptRuntimeException(this.Member.Span, $"Cannot get member with name {memberName}."); // unit test: 132-member-accessor-error2.txt
                }
            }

            return value;
        }

        public virtual async ValueTask SetValueAsync(TemplateContext context, object valueToSet)
        {
            var targetObject = await GetTargetObjectAsync(context, true).ConfigureAwait(false);
            var accessor = context.GetMemberAccessor(targetObject);
            var memberName = this.Member.Name;
            if (!accessor.TrySetValue(context, this.Span, targetObject, memberName, valueToSet))
            {
                throw new ScriptRuntimeException(this.Member.Span, $"Cannot set a value for the readonly member: {this}"); // unit test: 132-member-accessor-error3.txt
            }
        }
    }

    public partial class ScriptNamedArgument
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            if (Value != null)
                return await context.EvaluateAsync(Value).ConfigureAwait(false);
            return true;
        }
    }

    public partial class ScriptNestedExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            // A nested expression will reset the pipe arguments for the group
            context.PushPipeArguments();
            try
            {
                return await context.GetValueAsync(this).ConfigureAwait(false);
            }
            finally
            {
                if (context.CurrentPipeArguments != null)
                {
                    context.PopPipeArguments();
                }
            }
        }

        public async ValueTask<object> GetValueAsync(TemplateContext context)
        {
            return await context.EvaluateAsync(Expression).ConfigureAwait(false);
        }

        public async ValueTask SetValueAsync(TemplateContext context, object valueToSet)
        {
            await context.SetValueAsync(Expression, valueToSet).ConfigureAwait(false);
        }
    }

    public partial class ScriptObjectInitializerExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var obj = new ScriptObject();
            context.PushGlobal(obj);
            try
            {
                foreach (var member in Members)
                {
                    await member.EvaluateAsync(context).ConfigureAwait(false);
                }
            }
            finally
            {
                context.PopGlobal();
            }

            return obj;
        }
    }

    public partial class ScriptObjectMember
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var variable = Name as ScriptVariable;
            var literal = Name as ScriptLiteral;
            var name = variable?.Name ?? literal?.Value?.ToString();
            context.CurrentGlobal.TrySetValue(context, Span, name, await context.EvaluateAsync(Value).ConfigureAwait(false), false);
            return null;
        }
    }

    public partial class ScriptPage
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            return await context.EvaluateAsync(Body).ConfigureAwait(false);
        }
    }

    public partial class ScriptPipeCall
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            bool newPipe = context.CurrentPipeArguments == null;
            try
            {
                // Push a new pipe arguments
                if (newPipe)
                    context.PushPipeArguments();
                context.CurrentPipeArguments.Push(From);
                var result = await context.EvaluateAsync(To).ConfigureAwait(false);
                // If the result returns by the evaluation is a function and we haven't yet consumed the pipe argument
                // that means that we need to evaluate this function with the actual pipe arguments.
                if (result is IScriptCustomFunction && context.CurrentPipeArguments.Count > 0 && context.CurrentPipeArguments.Peek() == From)
                {
                    result = await ScriptFunctionCall.CallAsync(context, To, result, true, null).ConfigureAwait(false);
                }

                // If we have still remaining arguments, it is likely that the destination expression is not a function
                // so pipe arguments were not picked up and this is an error
                if (context.CurrentPipeArguments.Count > 0 && context.CurrentPipeArguments.Peek() == From)
                {
                    throw new ScriptRuntimeException(To.Span, $"Pipe expression destination `{To}` is not a valid function ");
                }

                return result;
            }
            catch
            {
                // If we have an exception clear all the pipe froms
                newPipe = false; // Don't try to clear the pipe
                context.ClearPipeArguments();
                throw;
            }
            finally
            {
                if (newPipe)
                {
                    context.PopPipeArguments();
                }
            }
        }
    }

    public partial class ScriptRawStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            if (Text == null)
                return null;
            if (Text.Length > 0)
            {
                // If we are in the context of output, output directly to TemplateContext.Output
                if (context.EnableOutput)
                {
                    await context.WriteAsync(Text).ConfigureAwait(false);
                }
                else
                {
                    return Text.ToString();
                }
            }

            return null;
        }
    }

    public partial class ScriptReturnStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var result = await context.EvaluateAsync(Expression).ConfigureAwait(false);
            context.FlowState = ScriptFlowState.Return;
            return result;
        }
    }

    public partial class ScriptTableRowStatement
    {
        protected override async ValueTask AfterLoopAsync(TemplateContext context)
        {
            await context.Write("</tr>").WriteLineAsync().ConfigureAwait(false);
        }

        protected override async ValueTask BeforeLoopAsync(TemplateContext context)
        {
            await context.WriteAsync("<tr class=\"row1\">").ConfigureAwait(false);
        }

        protected override async ValueTask<object> LoopItemAsync(TemplateContext context, LoopState state)
        {
            var localIndex = state.LocalIndex;
            var columnIndex = localIndex % _columnsCount;
            var tableRowLoopState = (TableRowLoopState)state;
            tableRowLoopState.Col = columnIndex;
            tableRowLoopState.ColFirst = columnIndex == 0;
            tableRowLoopState.ColLast = ((localIndex + 1) % _columnsCount) == 0;
            if (columnIndex == 0 && localIndex > 0)
            {
                await context.Write("</tr>").WriteAsync(context.NewLine).ConfigureAwait(false);
                var rowIndex = (localIndex / _columnsCount) + 1;
                await context.Write("<tr class=\"row").Write(rowIndex.ToString(CultureInfo.InvariantCulture)).WriteAsync("\">").ConfigureAwait(false);
            }

            await context.Write("<td class=\"col").Write((columnIndex + 1).ToString(CultureInfo.InvariantCulture)).WriteAsync("\">").ConfigureAwait(false);
            var result = await base.LoopItemAsync(context, state).ConfigureAwait(false);
            await context.WriteAsync("</td>").ConfigureAwait(false);
            return result;
        }

        protected override async ValueTask ProcessArgumentAsync(TemplateContext context, ScriptNamedArgument argument)
        {
            _columnsCount = 1;
            if (argument.Name?.Name == "cols")
            {
                _columnsCount = context.ToInt(argument.Value.Span, await context.EvaluateAsync(argument.Value).ConfigureAwait(false));
                if (_columnsCount <= 0)
                {
                    _columnsCount = 1;
                }

                return;
            }

            await base.ProcessArgumentAsync(context, argument).ConfigureAwait(false);
        }
    }

    public partial class ScriptThisExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            return await context.GetValueAsync(this).ConfigureAwait(false);
        }
    }

    public partial class ScriptUnaryExpression
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            if (Operator == ScriptUnaryOperator.FunctionAlias)
            {
                return await context.EvaluateAsync(Right, true).ConfigureAwait(false);
            }

            var value = await context.EvaluateAsync(Right).ConfigureAwait(false);
            if (value is IScriptCustomUnaryOperation customUnary)
            {
                if (customUnary.TryEvaluate(context, Right.Span, Operator, value, out var result))
                {
                    return result;
                }
            }
            else
            {
                switch (Operator)
                {
                    case ScriptUnaryOperator.Not:
                        {
                            if (context.UseScientific)
                            {
                                if (!(value is bool))
                                {
                                    throw new ScriptRuntimeException(Right.Span, $"Expecting a boolean instead of {value?.GetType().ScriptPrettyName()} value: {value}");
                                }

                                return !(bool)value;
                            }
                            else
                            {
                                return !context.ToBool(Right.Span, value);
                            }
                        }

                    case ScriptUnaryOperator.Negate:
                    case ScriptUnaryOperator.Plus:
                        {
                            bool negate = Operator == ScriptUnaryOperator.Negate;
                            if (value != null)
                            {
                                if (value is int)
                                {
                                    return negate ? -((int)value) : value;
                                }
                                else if (value is double)
                                {
                                    return negate ? -((double)value) : value;
                                }
                                else if (value is float)
                                {
                                    return negate ? -((float)value) : value;
                                }
                                else if (value is long)
                                {
                                    return negate ? -((long)value) : value;
                                }
                                else if (value is decimal)
                                {
                                    return negate ? -((decimal)value) : value;
                                }
                                else if (value is BigInteger)
                                {
                                    return negate ? -((BigInteger)value) : value;
                                }
                                else
                                {
                                    throw new ScriptRuntimeException(this.Span, $"Unexpected value `{value} / Type: {value?.GetType()}`. Cannot negate(-)/positive(+) a non-numeric value");
                                }
                            }
                        }

                        break;
                    case ScriptUnaryOperator.FunctionAlias:
                        return await context.EvaluateAsync(Right, true).ConfigureAwait(false);
                    case ScriptUnaryOperator.FunctionParametersExpand:
                        // Function parameters expand is done at the function level, so here, we simply return the actual list
                        return await context.EvaluateAsync(Right).ConfigureAwait(false);
                }
            }

            throw new ScriptRuntimeException(Span, $"Operator `{OperatorAsText}` is not supported");
        }
    }

    public abstract partial class ScriptVariable
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            return await context.GetValueAsync((ScriptExpression)this).ConfigureAwait(false);
        }
    }

    public partial class ScriptWhenStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var caseValue = context.PeekCase();
            foreach (var value in Values)
            {
                var whenValue = await context.EvaluateAsync(value).ConfigureAwait(false);
                var result = ScriptBinaryExpression.Evaluate(context, Span, ScriptBinaryOperator.CompareEqual, caseValue, whenValue);
                if (result is bool && (bool)result)
                {
                    return await context.EvaluateAsync(Body).ConfigureAwait(false);
                }
            }

            return await context.EvaluateAsync(Next).ConfigureAwait(false);
        }
    }

    public partial class ScriptWhileStatement
    {
        protected override async ValueTask<object> EvaluateImplAsync(TemplateContext context)
        {
            var index = 0;
            object result = null;
            await BeforeLoopAsync(context).ConfigureAwait(false);
            var loopState = CreateLoopState();
            context.SetValue(ScriptVariable.WhileObject, loopState);
            while (context.StepLoop(this))
            {
                var conditionResult = context.ToBool(Condition.Span, await context.EvaluateAsync(Condition).ConfigureAwait(false));
                if (!conditionResult)
                {
                    break;
                }

                loopState.Index = index++;
                loopState.LocalIndex = index;
                loopState.IsLast = false;
                result = await LoopItemAsync(context, loopState).ConfigureAwait(false);
                if (!ContinueLoop(context))
                {
                    break;
                }
            }

            ;
            await AfterLoopAsync(context).ConfigureAwait(false);
            return result;
        }

        protected override async ValueTask<object> LoopItemAsync(TemplateContext context, LoopState state)
        {
            return await context.EvaluateAsync(Body).ConfigureAwait(false);
        }
    }

    public partial class ScriptWithStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            var target = await context.GetValueAsync(Name).ConfigureAwait(false);
            if (!(target is IScriptObject))
            {
                var targetName = target?.GetType().Name ?? "null";
                throw new ScriptRuntimeException(Name.Span, $"Invalid target property `{Name}` used for [with] statement. Must be a ScriptObject instead of `{targetName}`");
            }

            context.PushGlobal((IScriptObject)target);
            try
            {
                var result = await context.EvaluateAsync(Body).ConfigureAwait(false);
                return result;
            }
            finally
            {
                context.PopGlobal();
            }
        }
    }

    public partial class ScriptWrapStatement
    {
        public override async ValueTask<object> EvaluateAsync(TemplateContext context)
        {
            // Check that the Target is actually a function
            var functionCall = Target as ScriptFunctionCall;
            if (functionCall == null)
            {
                var parameterLessFunction = await context.EvaluateAsync(Target, true).ConfigureAwait(false);
                if (!(parameterLessFunction is IScriptCustomFunction))
                {
                    var targetPrettyName = ScriptSyntaxAttribute.Get(Target);
                    throw new ScriptRuntimeException(Target.Span, $"Expecting a direct function instead of the expression `{Target}/{targetPrettyName.Name}`");
                }

                context.BlockDelegates.Push(Body);
                return await ScriptFunctionCall.CallAsync(context, this, parameterLessFunction, false, null).ConfigureAwait(false);
            }

            context.BlockDelegates.Push(Body);
            return await context.EvaluateAsync(functionCall).ConfigureAwait(false);
        }
    }
}
#endif
